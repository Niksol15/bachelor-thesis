#show "CAL_O": $cal(O)$

#let fontsize = 14pt
#show heading: set text(size: fontsize)
#show heading.where(level: 1): it => align(center)[#upper(it) \ ]
#set text(size: fontsize, font: "Times New Roman", lang: "ua")
#show raw: set text(size: fontsize)
#show raw: set par(leading: 0.5em)
#show math.equation: set text(size: 14pt)

#set page(
  paper: "a4",
  margin: (
    top: 20mm,
    bottom: 20mm,
    left: 25mm,
    right: 10mm
  ),
  header: align(right)[#counter(page).display(i => if i != 1 [#i])]
)

#align(center)[
  *КИЇВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ \
  ІМЕНІ ТАРАСА ШЕВЧЕНКА* \
  Факультет комп’ютерних наук та кібернетики \
  Кафедра математичної інформатики \ \ \
  *Кваліфікаційна робота \
  на здобуття ступеня бакалавра* \
  за освітньо-професійною програмою “Інформатика” \
  спеціальності 122 Комп'ютерні науки на тему: \ \
  *ІМПЛЕМЕНТАЦІЯ КРИПТОСИСТЕМ НА ОСНОВІ ЕЛІПТИЧНИХ КРИВИХ* \ \ \
]

#let signature = [
  \
  #line(length: 100%)
  #align(center, text(size: 0.8em, "(підпис)"))
]

#grid(
  columns: (70%, 30%),
  [
    Виконав студент 4-го курсу \
    Нікіта СОЛОНКО
  ],
  signature,
  [
    \
    Науковий керівник: \
    Член-кореспондент НАН України, професор \
    Анатолій АНІСІМОВ
  ],
  [\ \ #signature],
)

\ \
#grid(
  columns: (40%, 60%),
  [],
  [
    Засвідчую, що в цій роботі немає запозичень з
    праць інших авторів без відповідних посилань.

    #grid(
      columns: (50%, 50%),
      align(center)[\ Студент],
      signature,
    )
  ]
)

#align(center + bottom)[Київ -- 2023]
#pagebreak()

#heading(outlined: false)[Реферат]

Обсяг роботи:
#locate(loc => counter(page).final(loc).at(0)) сторінок,
#locate(loc => counter(figure.where(kind: image)).final(loc).at(0)) ілюстрацій,
#locate(loc => counter(figure.where(kind: table)).final(loc).at(0)) таблиць,
#yaml("./sources.yml").len() використаних джерел.

Ключові слова: ЕЛІПТИЧНІ КРИВІ, КРИПТОГРАФІЯ ЕЛІПТИЧНИХ КРИВИХ, CURVE25519, X25519, ED25519, КРИПТОГРАФІЯ З ВІДКРИТИМ КЛЮЧЕМ

Об'єктом дослідження є сучасна криптографія еліптичних кривих.

Метою кваліфікаційної роботи є порівняння 256 бітних еліптичних кривих, що використовуються у сучасній криптографії, шляхом дослідження математичних структур, на основі яких вони розроблені. Як результат дослідження пропозиція найбільш актуальної з них і розробка бібліотеки мовою С++, що імплементує криптосистеми на її основі. 

Інструментами створення є безкоштовний редактор коду 'VSCode' та мова розмітки тексту 'Typst', редактор коду 'Clion', мова програмування С++.

Результат роботи: шляхом проведення дослідження визначено, що найбільш перспективною кривою є Curve25519, оскільки вона дає найкращу швидкість роботи, з розглянутих кривих, в протоколі Діффі-Гелламана, що підтверджено бенчмарками. Також ця крива дає можливість використовувати цифровий підпис EdDSA, що перевершує ECDSA. Розроблено бібліотеку мовою С++, що імплементує криптосистеми на основі Curve25519: X25519 та Ed25519.

#pagebreak()

#outline()

#pagebreak()

= Скорочення та умовні позначення

/ SIMD: Single Instruction Multiple Data;
/ ECC: Elliptic curve cryptography;
/ EC: Elliptic curve;
/ DLP: Discrete Logarithm Problem, задача дискретного логарифму;
/ GNFS: General Number Field Sieve;
/ CDH: Computational Diffie–Hellman assumption;
/ DDH: Decisional Diffie–Hellman assumption;
/ NIST: U.S. National Institute of Standards;
/ MOV: Menezes, Okamoto and Vanstone
/ SEA: Schoof, Elkies, Atkin

#pagebreak()

#let leading = 18pt
#set par(leading: leading, first-line-indent: 1.27cm,)
#show par: set block(spacing: leading)
#show outline: set par(first-line-indent: 0mm)
#show terms: set par(first-line-indent: 0mm)

= Вступ

*Оцінка сучасного стану об’єкта дослідження* 

На даний момент, окрім того, що застосування еліптичних кривих у криптографії активно досліджується в академічних роботах, існує безліч прикладних
реалізацій ECC, що використовуються повсюдно. Більш того, криптосистеми з відкритим ключем, що використовують еліптичні криві, потроху стають
популярнішими за найбільш розповсюджений зараз RSA. Так, наприклад, нові версії ssh рекомендують використовувати алгоритм підпису Ed25519, що побудований
на еліптичних кривих Едвардса, замість RSA. Аналогічні рекомендації зараз дають такі сервіси як: GitLab, GitHub, Amazon Web Services, Google
Cloud Platform і багато інших.

*Актуальність роботи та підстави для її виконання*

Як було зазначено раніше, криптосистеми з відкритим ключем побудовані на основі еліптичних кривих вже активно використовуються, але все ще 
перебувають у стані розвитку. Так, наприклад, стаття @EdDSA, в якій була запропонований одна з найбільш популярних зараз еліптичних
кривих Curve25519 і алгоритм підпису/верифікації на її основі Ed25519, була написана в 2012 році, що для криптографії недавно. Також зараз 
існує багато програмних реалізацій таких криптосистем, але, у зв’язку зі складністю їх імплементації, не всі вони є цілком безпечними. Варто
зазначити, що  з кожним роком архітектура обчислювальних систем розвивається: оптимізуються існуючі інструкції та додаються нові, що відкриває
можливості як для оптимізації існуючих реалізацій, так і для написання нових - кращих. Наприклад, в архітектурі x64 апаратна підтримка SIMD
обчислень з 512 бітними регістрами AVX-512 @AVX з’явилася в 2013 році, вже після виходу статті з описом Ed25519.


*Мета й завдання роботи*

Метою роботи є дослідження застосування еліптичних кривих у сучасній криптографії та математичних основ криптографії еліптичних кривих, порівняння еліптичних кривих, що використовуються у сучасній криптографії і як результат дослідження імплементація криптографічної бібліотеки, що реалізує криптосистему на основі найбільш актуальної еліптичної кривої.

*Можливі сфери застосування*

Оскільки програмна реалізація, яка буде розроблена у рамках цієї роботи не буде сертифікована, то її не варто застосовувати в реальних
системах, на які може бути здійснена атака, але вона може бути застосована у навчальних і академічних цілях. В перспективі така бібліотека
може бути застосована всюди, де потрібна безпечна комунікація в умовах, коли можливе прослуховування, або втручання в  канал зв’язку, між
сутностями, які ще не узгодили симетричний ключ, наприклад: TLS, HTTPS, SSH і так далі. 

#pagebreak()

#set heading(numbering: (..nums) => {
  if nums.pos().len() == 1 {
    "Розділ " + str(nums.pos().at(0)) + "."
  } else {
    numbering("1.", ..nums)
  }
})

= ЕЛІПТИЧНІ КРИВІ
== Переваги над $ZZ_p^*$
\

Під $ZZ_p^*$ мається увазі мультиплікативна група лишків за модулем p, де p - просте число.

Розглянемо мотивацію використання нового криптографічного примітиву, коли вже побудовано і імплементовано багато криптосистем на основі
$ZZ_p^*$, таких як: Діффі-Геллман, Ель-Гамаль, RSA і багато інших. Проблема використання таких криптосистем полягає у тому, що вони були 
запропоновані давно: Діффі-Геллман @DH - 1976, RSA @RSA - 1978, Ель-Гамаль @ElGamal - 1985. З того часу кратно збільшились обчислювальні
можливості. Частота ядер виросла з кГц до ГГц, кількість ядер збільшилась з одиниць до сотень, з’явилися зручні інструменти для об’єднання
процесорів у кластери. Також, через бажання зламати дані криптосистеми, багато вчених шукали спосіб знайти більш  ефективні алгоритми
розв'язання проблем на які вони спираються. Таким чином у 1993 Ленстра @GNFS придумав ефективний алгоритм розкладання великих чисел на
множники - GNFS(General Number Field Sieve), який може розкласти число $n > 10^100$ за час:
$ exp( ((64/9) ^ (1/3) + o(1)) (log n) ^ (1/3) (log log n) ^ (2/3)) $
Це стало основною проблемою криптосистем на основі $ZZ_p^*$, тому що він робить вирішення обчислювальних проблем, на які спираються ці
криптосистеми субекспоненційним, замість експоненційних. Варто зазначити, що цей алгоритм не є чисто теоретичною загрозою. За його 
допомогою у 2019 році @BonehShoup було знайдено дискретний логарифм 795 бітного числа. Таким чином, в патенті RSA @RSA рекомендований 
розмір ключів був 200біт, в першій NIST сертифікації - 512 біт, зараз же мінімальний рекомендований розмір - 2048 біт. Важливим також є те,
що GNFS неможливо узагальнити на будь-які скінчені циклічні групи, тому він не зачіпає групу точок еліптичної кривої над скінченним полям
(позначення буде наведено далі). По цій причині найкращий відомий алгоритм для вирішення проблеми дискретного логарифма для групи точок 
еліптичних кривих (ECDLP) займає час $O(sqrt(q))$, де q - розмір групи. Через це розміри ключів, що мають однакову безпеку для $ZZ_p ^ *$ і для 
групи точок кліптичної кривої сильно відрізняються. Порівняльна характеристика безпеки ключа в залежності від розміру ключа RSA/Diffie-Hellman
і ECC:

#figure(
  image("resources/key-size-comparison.jpg"),
  caption: [
    @KeyCmpImg
  ],
) \

Як можна побачити з наведеної таблиці, використання еліптичних кривих дає вагому перевагу, оскільки зменшує розмір ключа, що в свою чергу
зменшує час, потрібний на проведення операцій з ключем (що дає виграш у швидкодії), кількість затраченої енергії (що є вагомою перевагою для 
IoT), навантаження на мережу під час передачі ключа і загалом трафік.

Ще однією перевагою криптографії еліптичних кривих є те, що можна використати багато напрацювань з криптографії з відкритим, що використовує
$ZZ_p^*$. Це випливає з того ECC як складно обчислювальну проблему використовує знаходження дискретного логарифма - DLP(у випадку еліптичних кривих 
вживають термін ECDLP), аналогічно до складно обчислювальної проблеми в Діффі-Геллман і ЕльГамаль. До того ж, еліптичні криві мають додаткову
структуру, яку не має $ZZ_p ^ *$, що дозволяє побудувати неможливі для $ZZ_p ^ *$ криптосистеми. Такою додатковую структурою є можливість 
будувати спарювання точок еліптичних кривих(pairing), алгебраїчні решітки(lattices), ізогенії(isogenies). Алгебраїчні решітки і ізогенії
еліптичних кривих зараз активно використовуються для побудови пост-квантових криптосистем з відкритим ключем.


== Загальний огляд еліптичних кривих
\

=== $E slash RR$
\

Існує декілька форм задання еліптичних кривих. Почнемо з найбільш класичної:

Еліптичною кривою $E$ називається множина точок, що є розв'язком рівняння: $y^2 = x^3 + a x + b$.

Наведене рівняння називають рівнянням Веєрштрасса і, відповідно, дану форму задання еліптичної кривої називають формою Веєрштраса.
Якщо еліптична крива задана над полем $FF$, будемо позначати це як $E slash FF$

#figure(
  image("resources/EC-example.png"),
  caption: [
    Ілюстрація 2 еліптичних кривих з @MathCrypto
  ],
) \

Еліпітичні криві є не просто об'єктом вивчення аналітичної геометрії, а й цікавим об'єктом розгляду алгебри, бо над точками еліптичної кривої можна проводити обчислення. 
Перед переходом до еліптичних кривих над скінченими полями, для більш інтуїтивного розуміння, розглянемо як "додавати" точки
еліптичної кривої над $RR$, бо це можна легко інтерпретувати геометрично. Позначемо операцію додавання точок еліптичної кривої як $plus.circle$ і розглянемо її на 
прикладі з @MathCrypto. 

Для початку визначимо, що якщо $A = (x, y) in E ", то" -A = (x, -y) in E$. Нехай $E slash RR$ - це еліптична крива задана рівнянням $y^2 = x^3 - 15x + 18$; 
Точки $P = (7, 16), Q = (1, 2) in E$, тоді пряма $L$, що їх сполучає задається рівнянням: $y = 7/3 x - 1/3$. Для того, щоб знайти в яких точках $L$ перетинає $E$ 
ми можемо підставити заміcть $y$ рівність з $L$ в $E$ і розв'язати рівняння відносно $x$. Для наведеного прикладу маємо:

$(7/3 x - 1/3) ^ 2 = x^3 -15 x + 18 arrow.r x^3 - 49/9 x^2 - 121/9 x + 161/9 = 0$

Отримане рівняння є рівнянням третьої степені, отже воно має 3 корені, 2 з яких нам вже відомі, залишається знайти третій корінь. Найлегшим способом є поділити отриманий поліном на 
$(x - 7)(x - 1)$. Таким чином отримуємо третій корінь $x = -23/9$. Підставляючи $x$ в $E$ отримуємо $y = -170/27$, а отже точку $R = (-23/9, -170/27)$. 
Далі відображаємо $R$ відносно OX:

$P plus.circle Q = -R = R' = (-23/9, 170/27)$

Цей метод називається методом хорди. Наведене вище в графічно:

#figure(
  image("resources/P_plus_Q.png"),
  caption: [
    $P plus.circle Q$ з @MathCrypto
  ],
) \

Розглянемо випадок $P plus.circle P = 2P = R'$. Для цього проведемо дотичну до $E$ в точці $P$. Для цього потрібно діференціювати $E$ по $x$. На прикладі, який розглядався раніше:

$2y (dif y)/(dif x) = 3 x^2 -15 arrow.r (dif y) / (dif x) = (3 x^2 - 15) / (2 y)$

Підставляючи координати $P = (7, 16)$ отримуємо $L: y = 33/8 x - 103/8$. Аналогічно попередньому прикладу знаходимо $R = (193/64, -223/512)$, а отже 

$P plus.circle P = R' = -R = (193/64, 223/512)$

Цей метод називається методом дотичної. Наведене вище в графічно:

#figure(
  image("resources/P_plus_P.png"),
  caption: [
    $P plus.circle P$ з @MathCrypto
  ],
) \


Залишилось розглянути останній випадок: $P plus.circle (-P)$. Для цього введемо спеціальну точку, що називається точкою на нескінченості: $cal(O)$, 
тоді $P plus.circle (-P) = cal(O)$. Графічно це виглядає наступним чином:

#figure(
  image("resources/P_minus_P.png"),
  caption: [
    $P plus.circle (-P) = cal(O)$ з @MathCrypto
  ],
) \

Формальний кінцевий алгоритм, що покриває всі вищенаведені випадки, буде наведено у наступному підрозділі.

=== $E slash FF_p$
\ 

Перейдемо до еліптичних кривих, що застосовуються у криптографії - еліптичних кривих над скінченимими полями.
Почнемо з визначення:

Нехай $p > 3$ - простe число. Тоді еліптичною кривою $E$ визначеною над $FF_p$ є множина розв'язків рівняння $y^2 = x^3 + a*x + b$, де $a, b in FF_p$ задовільняють умову 
$4 a^3 + 27 b^2 eq.not 0$. Ця умова потрібна, щоб впевнитись, що рівняння $x^3 + a x + b = 0$ має тільки один корінь. У випадку, якщо попередня властивість не виконується, 
рівняння кривої буде мати 2, або 3 однакових кореня. Нехай у такому випадку коренем рівняння кривої буде $x_0$, тоді точка $(x_0, 0)$ називається сингулярною, і 
відповідна крива теж називається сингулярною.

Множиною точок еліптичною кривої $E slash FF_p: y^2 = x^3 + a x + b; a, b in FF_p$ є $E(F_p) = {(x, y): x, y in FF_p and y^2 = x^3 + a x + b} union {cal(O)}$. 

Розглянемо приклад. Нехай $E: y^2 = x^3 + 1$ визначена на $FF_(11)$, тоді: 
$E(FF_(11)) = { cal(O), (−1, 0), (0, plus.minus 1), (2, plus.minus 3), (5, plus.minus 4), (7, plus.minus 5), (9, plus.minus 2)}$

Тепер розглянемо $plus.circle$ для $E(FF_p)$. Для цього будемо спиратися на результати розгляду $(E(RR), plus.circle)$, бо для $E(FF_p)$ алгоритм виглядає аналогічно 
до алгоритму для $E(RR)$, але його не вдасться легко інтерпретувати геометрично. Розглядом геометричної інтерпретації обчислень над точками еліптичних кривих над 
скінченими полями займається алгебраїчна геометрія і це виходить за рамки даної роботи. Нехай $P = (x_p, y_p) or cal(O), Q = (x_q, y_q) or cal(O) in E(FF_p)$:
- Якщо $P = cal(O) arrow.r P plus.circle Q = Q$
- Інакше, якщо $Q = cal(O) arrow.r P plus.circle Q = P$
- Інакше, якщо $Q = -P arrow.r P plus.circle Q = cal(O)$ (варто зазначити що це покриває випадок коли $y_p = y_q = 0$)
- Інакше, якщо $P = Q$ використовуємо метод дотичної: $lambda = (3x_p + a) / (2y_p)$
- Інакше використовуємо метод хорди: $lambda = (y_q - y_p) / (x_q - x_p)$
- $x = lambda ^ 2 - x_p - x_q; y = lambda(x_p - x) - y_p arrow.r P plus.circle Q = (x, y)$

$(E(FF_p), plus.circle)$ утворюють циклічну абелеву групу.

Наведений вище алгоритм для еліптичних кривих загального вигляду має 2 основних недоліки:
+ Він не є достатньо швидким. Як буде розглянуто далі, існують спеціальні види еліптичних кривих, для яких його можна прискорити.
+ Імплементація додавання точок еліптичної кривої має працювати за константний час, інакше можлива атака по часу(timing attack) що викриває приватний ключ. Як можна побачити, даний алгоритм важко реалізувати таким чином, щоб він працював за константиний, час через різну кількість обчисленнь за різних умов.

Властивість, коли алгоритм обчислення $plus.circle$ має єдину формулу для усіх точок в $E(FF_p)$ при будь яких умовах, тобто може бути імплементований без умовних операторів, називається повний закон додавання(complete addition law).

У 2015 для кривих Веєрштрасса знайшли формулу для повного закону додавання @WCAL. Але, оскільки формула дуже об'ємна, вона тут не наводиться.

== Додаткові обчислення в $E(FF_p)$
=== $|E(FF_p)|$
Однією з найважливіших характеристик еліпитичної над скінченим полем є $q = |E(FF_p)|$ - розмір групи. Стосовно цієї характеристики існує теорема Гассе(Hasse):

Нехай $E slash FF_(p^e)$, тоді: $|E(FF_(p_e))| = p^e + 1 - t_(p^e); t_(p^e) lt.eq 2 sqrt(p^e)$ - називається слідом Фробеніуса.

Важливим є здатність точно обчислити $|E(FF_(p_e))|$. Вперше ефективний алгоритм запропнував Скуф(Schoof) в @Schoof, потім Елкіс(Elkies) і Еткін(Atkin) запропонували поліпшення
складності роботи цього алгоритму @SEA. Результат називається SEA, він залишається найшвидшим алгоритмом до цього часу і має складність 
$O(log^2 p * M(log^2 p) slash log log p)$, де $M(n)$ - складність множення.

Ще однією характеристикою кривої є кофактор. Нехай $E slash FF_p$ має підгрупу порядку $q$, де $q$ - велике просте число. Зазвичай обчислення над еліптичною кривою проводяться саме в цій пігрупі. Тоді, кофактором $ h = |E(FF_p)| / q$

=== Скалярдний добуток точки на число

Більшість ECC криптосистем використовують обчислення $n P, P in E(FF_p)$. Для того, щоб ці системи було можливо використовувати на практиці, це обчислення має бути швидким. Спочатку визначимо формально, що

$P in E(FF_p), n gt.eq 1 in NN: n P = (n - 1) P plus.circle P$

Очевидний приклад: $3P = P + 2P = P + P + P$. Також зрозуміло що обчислювати $n P$ наївно, за $n - 1$ додавань - неоптимально, тому використовують оптимізації:

*Подвоюй-і-Додавай (Double-and-Add)*.
За допомогою цієї оптимізації можна обчислити $n P$ за не більше ніж $2 log_2 n$ додавань. Існують 2 версії цього алгоритму: яка використовує інверсію($P -> -P$) і яка не використовує. Варто відзначити, що знаходження точки еліптичної кривої оберненою до даної - тривільне і швидке, і перша версія для випадковго $n$ потребує меншу кількість операцій у середньому. Приклад реалізації другого варіанту з використанням псевдокоду:

```
Double-and-Add(P, n):
  Q := P
  R := CAL_O
  while n > 0:
    if n ≡ 1 (mod 2):
      R := R + Q
    Q := 2 * Q
    n := n / 2
  return R
```

На практиці, якщо потрібно обчислити, наприклад, $947 P$ першим методом буде обчислено:

$947 P = P plus.circle 2 P plus.circle (-2^4 P) plus.circle (-2^6 P) plus.circle 2^10 P$

#par(first-line-indent: 0cm)[А другим:]

$ 947 P = P plus.circle 2 P plus.circle 2^4 P plus.circle 2^5 P plus.circle 2^7 P plus.circle 2^8 P plus.circle 2^9 P$

Недоліком цього алгоритму є те, що час його роботи залежить від значення $n$. Це робить його вразливим до timing attack. 

*Сходи Монтгомері (Montgomery ladder)*. 
Цей алгоритм має аналогічну часову складіність до алгоритму Double-and-Add, але його перевагою є те, що час його роботи залежить від кількості бітів в $n$, а не від самого значення, що робить його невразливим до timing-attack при умові якщо $plus.circle$ також не вразлива до неї. Сам алгоритм @MontLadder, нехай $n = (n_(t-1),...,n_0)_2$, кількість бітів в $n = t$ позначимо $n[i] = n_i$:

```
MontgomeryLadder(P, n):
  R := CAL_O
  Q := P
  for i = t - 1 downto 0:
    if n[i] = 0:
      Q := Q + R
      R := R + R
    else:
      R := R + Q
      Q := Q + Q
  return R       
```

Нехай $x(P), P in E(FF_p)$ - $x$ координата точки $P$. Також, модифікація наведеної імплементації цього алгоритму дозволяє обчислити $x(n P)$ знаючи тільки $x(P)$, використовуючи наступні формули:

$text("Якщо ") (2 alpha) P != cal(O): x_(2 alpha) = 1/4 ((x_alpha ^ 2 - a) ^ 2 - 8 b x_alpha) slash (x_alpha ^ 3 + a x_alpha +b)$

$text("Якщо ") (2 alpha + 1) P != cal(O): x_(2 alpha + 1) = ((a - x_alpha x_(alpha + 1)) - 4 b (x_alpha + x_(alpha + 1))) slash (x_1 (x_alpha - x_(alpha + 1) ^ 2))$

Як висновок, можна резюмувати, що швидкість добутку точки на число є важливою характеристикою еліптичної кривої. Існують криві, для яких можна оптимізувати як одиничну операцію $P + Q$, так і обчислення $n P$ в цілому.

=== Дискретний логарифм в $E(FF_p)$

Нехай $E$ - еліптична крива, $FF_p$ - скінчене поле, $P in E(FF_p), Q in angle.l P angle.r$, тоді дискретним логарифмом $Q$ за основою $P$ є таке $n$, що 
$Q = n P$ і позначається $n = log_P Q$.

Нехай $q$ - порядок $P$, тоді очевидно що, якщо $Q = n_0 P$, то $Q = (n_0  + i q) P, forall i in NN$. Для визначеності будемо вважати, що дискретний логарифм - 
це найменше таке $n$, що $Q = n P$. У такому випадку зрозуміло, що $log_P(Q) in ZZ_q$.

Важливо відмітити, що для дискретного логарифму точок еліптичної кривої виконується властивість звичайного логарифму:

$log_P(Q_1 + Q_2) = log_P(Q_1) + log_P(Q_2), forall Q_1, Q_2 in angle.l P angle.r$

З цього випливає, що $log_P$ визнчає груповий гомоморфізм:

$log_P: angle.l P angle.r arrow.r ZZ_q$

Зазвичай на практиці $P$ вибирається з генераторів $E(FF_p)$.

ECDLP - проблема знаходження дискретного логарифму для точок еліптичної кривої.

== Спарювання точок еліптичної кривої(Pairing)

$E slash FF_p$ має додаткову структуру - pairing. Вона може бути використана для побудови криптосистем неможливих для циклічних груп у загальному випадку, а також 
для $ZZ_p^*$ і дозволяє розширити множину криптосистем ECC. Зазвичай у визначенні використовують мультиплікативні групи, замість адитивних, але оскільки ця робота сконцентрована
саме на еліптичних кривих, то:

Нехай $GG_0, GG_1, GG_T$ - циклічні групи порядку $q$, де $q$ - просте. $g_0 in GG_0, g_1 in GG_1$ - генератори. Pairing - це ефективно обчислювальна функція $e: GG_0 times GG_1 arrow.r GG_T$, яка задовільняє наступні вимоги:

1. Білінеарність. $forall u, u' in GG_0, forall v, v' in GG_1$:

$e(u + u', v) = e(u, v) e(u', v) and e(u, v + v') = e(u, v) e(u, v')$

2. Недегенаривність: $g_T = e(g_0, g_1)$ - генератор в $GG_T$

Коли $GG_0 = GG_1$ назвемо це спарювання симетричним, інакше - асиметричним.
$GG_0, GG_1$ називаються pairing groups(спарювані групи), а $GG_T$ - target group(цільовою групою).

З білінеарності випливає основна властивість спарювання, яка використовується в побудові криптосистем:

$forall alpha, beta in ZZ_q: e(g_0 ^ alpha, g_1 ^ beta) = e(g_0, g_1) ^ (alpha beta) = e(g_0 ^ beta, g_1 ^ alpha)$

Вимога недегенеративності потрібна, щоб $e$ не повертала завжди $1 in GG_T$ для всіх аргументів.

Найбільш зручним і ефективним спарюванням для $E slash FF_p$ - є асиметричне спарювання. Спарювання сконструйоване з $E slash FF_p$ має групи $GG_0, GG_1,GG_T$ з наступними властивостями:

- $GG_0$ - це підгрупа $E(FF_p)$ порядку q, де q - просте.
- $GG_1$ - це підгрупа $E(FF_(p^d))$ порядку q, для деякого $d in NN > 0$, де $GG_0 sect GG_1 = {cal(O)} $
- $GG_T$ - це мультиплікатитвна група 

Число $d in NN$ називається embedding degree (ступіню вкладенння) кривої. Зрозуміло, для того що спарювання було ефективним $d$ має бути малим, тому що, якщо $d$ буде великим неможливо буде ефективно записати елемменти в $GG_1$ та $GG_T$. Еліптитчні криві, де спарювання мале, наприклад $d lt.eq 16$, називають pairing friendly elliptic curves (еліптичними кривими дружніми для спарювання).

Оригінально почали використовувати Спарювання Вейля (Weil pairing). Нехай $m in NN, P in E: m P = cal(O)$. Точка $P$ є точкою скінченого порядку на еліптичній кривій, або торсіонною точкою (torsion point). Більш точно кажуть, що $P$ є точкою порядку m. Позначимо множину точок порядку m як:

$E(FF_p)[m] = {P in E(FF_p): m P = cal(O)}$

Тоді, нехай $f_P, f_Q$ - раціональні функції над $E$ (не наводжу тут визначення, ознайомитися з цією концепцією можна в @MathCrypto, @ECNTC), такі що: $text("div")(f_P) = m[P] - m[cal(O)], text("div")(f_Q) = m[Q] - m[cal(O)]$, тоді Weil pairing це:

$e_m(P, Q) = (f_P(Q + S))/(f_P(S)) slash (f_P(P - S))/(f_P(-S)), text(", де") S in E, S in.not {cal(O), P, -Q, P - Q}$

Для побудови спарювання Вейля існує ефективний алгоритм Міллера @MillerAlgo (Miller's algorithm). Але на практиці зараз використовують спарювання Тейта(Tate pairing) та спарювання Ейта(Ate pairing), оскільки алгоритм Міллера для них ефективніший.

== Спеціальні види еліптичних кривих

=== Крива Монтгомері

Еліптична крива $E slash FF_p$ у формі Монгомері у зміних $u, v$ має вигляд:

$B v^2  = u ^ 3 + A u^2 + u; A, B in FF_p, B(A^2 - 4) != 0$

Це рівняння кривої може бути легко приведено до рівняння Веєрштрасса заміною  зміних: $u = B x - A/3; n = B y$. Цікавою особливістю кривої Монгомері є те, що $|E(FF_p)|$ завжди ділиться на 4. З цього також випливає, що не кожну криву у формі Веєрштраса можна привести до кривої у формі Монтгомері заміною зміних.

Криві Монгомері дозволяють пришвидшити операцію додавання, шляхом оптимізації алгорима Монтгомері. Нехай $X_1 = x(P), Z_1 = 1$, і:

$X_(2 alpha) = (X_alpha ^ 2 - Z_alpha ^2)^2$

$Z_(2 alpha) = 4 X_alpha Z_alpha(X_alpha^2 + A X_alpha Z_alpha + Z_alpha ^ 2)$

$X_(2 alpha + 1) = 4Z_1(X_alpha X_(alpha+1) − Z_alpha Z_(alpha+1)) ^ 2$

$Z_(2 alpha + 1) = 4X_1(X_alpha Z_(alpha+1) − Z_alpha X_(alpha+1)) ^ 2$

Тоді $x(alpha P) = X_alpha slash Z_alpha$, якщо $alpha P != cal(O)$

Варто зазначити, що чим меньше А - тим швидше буде обчислення.

=== Крива Едвардса

Еліптична крива $E slash FF_p$ формі Едвардса має вигляд:

$x^2 + y^2 = 1 + d x^2 y^2, d != 0,1 in FF_p$

Аналогічно кривій Монтгомері, крива Едвардса може бути приведена до форми Вейерштраса заміною зміних, але не навпаки. $|E(FF_p)|$ завжди ділиться на 4. Перевагою кривих Едвардса є те, що $plus.circle$ дуже просто імплементувати:

$forall P, Q in E(FF_p): P plus.circle Q = ( (x_1 y_2 + x_2 y_1) / (1 + d x_1 x_2 y_1 y_2), (y_1 y_2 - x_1 x_2) / (1 - d x_1 x_2 y_1 y_2))$

Для цього визначемо $cal(O) = (0, 1)$. Як можна побачити криві Едвардса мають повний закон додавання.

=== Крива Кобліца

Оригінально крива була запропонована Кобліцом над $FF_2$ і мала вигляд:

$E: y^2 + x y = x^3 + a x^2 + 1, a in {0, 1}$

Після цього почалося дослідження цієї кривої над $FF_(2^m)$, для цього поля вона має вигляд:

$y^2 + x y = x^3 + a x^2 + b, b != 0$

Але, оскільки на практиці частіше застосовують криві цього виду над $FF_p$, і дана робота зосересереджена на $E slash FF_p$, сконцентруємося саме на кривих Кобліца над $FF_p$. Крива Кобліца $E$ над $FF_p$ задаєтсья рівнянням @KoblitzOverP :

$E: y^2 = x^3 + b, b != 0, p ident 1 (mod 3)$

В більш широкому розуміні кривими Кобліца називають еліптичні криві, для яких існує ефективно обчислювальний нетривіальний ендоморфізм $phi.alt: forall P, Q : phi.alt(P + Q) = phi.alt(P) + phi.alt(Q)$, який дозволяє оптимізувати операцію множення точки на число. Для $E(FF_(2^m))$ використовують ендоморфізм Фробеніуса: $phi.alt: FF_(p^k) arrow.r FF_(p^k), alpha arrow.r alpha ^ p$. Застосовуючи його для $E slash FF_(2^m)$ отримуємо $ P = (x,y) in E(FF_(2^m)), phi.alt(x,y)=(x ^ 2,y ^ 2)$. Для $E slash FF_p$ використовують енфоморфізм $phi.alt(x, y) = (omega x, y), 1 != omega in FF_p, omega ^ 3 = 1$. Зрозуміло, що таке не одиничне $omega$ знайдеться, оскільки $p ident 1(mod 3)$, що означає, що 1 має 3 кубічних кореня: $1, u, u^2 (u in FF_p)$. 

Легко перевірити, що якщо $(x, y) in E(FF_p)$, то і $phi.alt(x, y) = (omega x, y) in E(FF-p)$, оскільки $y ^ 2 = x^3 + b = (omega x)^3 + b = omega^3 x^3 +b = x^3 + b$. Також додатково визначемо, що $phi.alt(cal(O)) = cal(O)$. Тобто доведно, що $phi.alt: E(FF_p) arrow.r E(FF_p)$.

Нехай $q = |E(FF_p)|$. Оскільки, $phi.alt$ є ендоморфізмом і $E(FF_p)$ - циклічна група, має існувати таке $lambda in ZZ_q$, що: $forall P in E(FF_p): phi.alt(P) = lambda P$. Можливо визначити $lambda$ наступним чином. Очевидно що $P, phi.alt(P), phi.alt ^ 2 (P)$, мають однакову $y$ координату, а отже знаходяться на одній прямій, до того ж горизонтальній. З геометричної інтерпретації $plus.circle$ відомо, що це означає, що їх сума $cal(O)$, отже:

$forall P in E(FF_p): cal(O) = P plus.circle phi.alt(P) plus.circle phi.alt ^ 2(P)= P plus.circle lambda P plus.circle lambda ^ 2 P = (1 + lambda + lambda^2) P$

Звідки можемо зробити висновок, що
$1 + lambda + lambda ^ 2 = 0 arrow.r (lambda - 1)(1^2 + 1 * lambda + lambda^2) = 0 * (1 - lambda) arrow.r lambda^3 - 1 = 0 arrow.r lambda^3 = 1$

Тобто $lambda$, аналогічно до $omega$, це один з двох нетривіальних кубічних коренів 1.

Тепер розглянемо як $phi.alt$ може допомогти в прискорені обчислення $n P$. Нехай $n in ZZ_q$ і мета обчислити $n P$ для деякого $P in E(FF_p)$. Для більшості таких $n$ можливо знайти такі $tau_0, tau_1, tau_2 in ZZ$, що:

$n = tau_0 + tau_1 lambda + tau_2 lambda ^ 2 and |tau_i| lt.eq 2 q ^(1/3) text("для") i = 0, 1, 2$

Тобто, $n P = tau_0 + tau_1 phi.alt(P) + tau_2 phi.alt ^ 2(P)$

Така оптимізація дозволяє прискорити операцію множення у 2-3 рази @BonehShoup в порівнянні з Double-and-Add.

== Припущення на яких будується ECC
=== ECDLP
Основне припущення ECC полягає у тому, що ECDLP для точок еліптичної кривої над скінченим полем є 
складнообчислювальною проблемою, тобто не існує ефективного алгоритму обчислення дискретного логарифму.

На ECDLP існує багато атак - алгоритмів знаходження дискретного логарифма. Ним присвячена ціла глава в @ECNTC. Нехай $P, Q in E(FF_p), |E(FF_p)| = q$. Перша група атак працює для будь якої циклічної групи:
- Baby Step, Giant Step. Має часову складність $O(sqrt(q))$ і потребує $O(sqrt(q))$ місця. Цей алготирм є детерміністичним
- Алгоритми $rho$ і $lambda$ Полларда. $rho$ є узагальненням $lambda$ алгоритму. Вони також мають часову складність $O(sqrt(q))$, але потребують тільки $O(1)$ додаткового місця. Також треба зазначити, що цей алгоритм є ймовірніснім, тобто він знаходить дискретний логарифм з якоюсь високою, не 100%, ймовірністю, якщо логарифм існує.
- Метод Поліга-Геллмана @PohligHellman (The Pohlig-Hellman method). Ефективний якщо $q$ не є простим і в його факторизації нема великих простих чисел. Нехай $q = product_i p_i ^ e_i$, тоді складність часова складність цього алгоритму $O(sum_i e_i(log q  + sqrt(p_i)))$

Такж існує група атак, що використовують pairing. Такими атаками є:
- MOV(Menezes, Okamoto and Vanstone) @MOV. Ця атака використовує спарювання Вейля щоб звести ECDLP в $E(FF_p)$ до DLP в $FF_(p ^ m)$ 
- Атака Фрея-Рюка @FrayRuck (The Frey-Rück Attack). Аналогічно MOV, тільки використовується більш ефективне спарювання Тейта.

Оскільки ECC грунтується на припущені про обчислювальну складність ECDLP і ECC активно використовується в реальних криптосистемах, можна припустити, що для будь якої 
кривої $E slash FF_p$, де $p$ - достатньо велике просте число - ECLP складнообчислювальна проблема. Це є хибним твердженням, у тому числі через наведені вище атаки, наприклад:

- Якщо $|E(FF_p)|$ не є простим і всі прості множники у його розкладі менші деякого $q_max$, то тоді можливо застувати атаку з викристанням метода Поліга-Геллмана. Зокрема, якщо $q_max lt 2 ^ 80$, то ECDLP не є складнообчислювальною проблемою на практиці. Тому в реальних системах використовують криві $E slash FF_p$ для яких $|E(FF_p)|$ рівне $q, 4q, " або " 8q$ для деякого простого $q$.  

- Якщо $|E(FF_p)| = p$, то ECDLP для $E(FF_p)$ розв'язний за поліноміальний час. Такі криві називаються аномальнимим і не використовуються на практиці

- Нехай існує таке мале $tau > 0 in NN$, що $|E(FF_p)|$ ділить $p^tau - 1$. Тоді ECDLP в $E(FF_p)$ можна звести до DLP в $FF_(p^tau)$ використовуючи MOV, або атаку Фрея-Рюка, що в свою чергу дозволить використати GNFS. На практиці, якщо $p$ - 256 бітне число і $tau = 2$, то розв'язок ECDLP займе приблизно пару годин. Для захисту від цієї атаки, треба переконатися що $p^tau$ достатньо велике для того щоб GNFS в $FF_(p ^ tau)$ був нездійсненний.

Але, якщо параметри кривої підібрано правильно, то найоптимальніший алгоритм вирішення ECDLP має часову складність $O(sqrt(q)) text(", де") q = |E(FF_p)|$.

=== CDH

Нехай $GG - angle.l g angle.r$ - циклічна група порядку $q$, $a, b in ZZ_q$.
Припущення полягає у тому, що якщо зловмисник перехопив $g, g^a, g^b$ він не зможе обчислити $g^(a b)$. Зараз єдиним відомим спрособом роз'язати CDH є розв'язати DLP, але не доведено, що DLP і CDH - це рівнозначні проблеми. CDH є сильнішим припущенням, ніж DLP. Окрім цього цікавою особливістю CDH є те, що на відміну від RSA, не існує ефективного способу перевірити по заданому $g^c$, чи дійсно $g^c = g^(a b)$ маючи $g, g^a, g^b$.

=== DDH

Нехай  $GG - angle.l g angle.r$ - циклічна група порядку $q$, $a, b, с in ZZ_q$ обрані випадково. Припущеня полягає у тому, що зловмисник не може знаючи $g, q$ відрізнити $(g^a, g^b, g ^c)$ від $(g^a, g^b, g^(a b))$. Це припущення є сильнішим ніж CDH.

== Скручені криві (Twist curves)

Кожна еліптична крива $E slash FF_p$ має пов'язану з нею криву $tilde(E) slash FF_p$, яка називається twist of E(скрученою кривою Е). Нехай $c in FF_p$ не є квадратичним лишком в $FF_p$. Якщо E задається рівнянням $y^2 = x^3 + a x + b$, тоді $tilde(E)$ задається рівнянням $c y^2 = x ^3 + a x + b$.
Нескладно показати, що $|E(FF_p)| + |tilde(E)(FF_p)| = 2p + 2$, з цього, з використанням теореми Гассе, випливає що $|tilde(E)(FF_p)| = p + 1 - t$.

Визначемо, що крива $E slash FF_p$ twist secure(безпечно скручена), якщо ECDLP складно розв'язний як в $E slash FF_p$, так і в $tilde(E) slash FF_p$. 

Розглянемо для чого потрібна twist security. Нехай Боб має секретний ключ $alpha in ZZ_q$. а надіслане $P in E(FF_p)$ Боб відправляє $alpha P$. Для того, щоб система була безпечною Боб має перевіряти чи $P in E(FF_p)$, але нехай замість того щоб відсилати $P = (x, y)$, відсилається тільки $x(P)$ координата, тоді також можна як і отримати $y$, так і перевірити чи $in E(FF_p)$. Тоді, перевірка $P in E(FF_p)$ зводиться до перевірки чи є $y^2 = x^3 + a x + b$ квадратичним лишком в $FF_p$, що є відносно дорогою по часу операцією. Нехай, у такому випадку при імплементації крок перевірки був пропущений. Тоді, зловмисник може надіслати Бобу $x_1 = x(tilde(P)) in FF_q, tilde(P) in tilde(E) slash FF_q$. Якщо ECDLP легкорозв'язний в $tilde(E) slash FF_q$, тобто $E slash FF_p$ не twist secure, то відповідь Боба розкриє його секретний ключ. У випадку, якщо $E slash FF_p$ twist secure, то Бобу не загрожує така атака і він може використовувати оптимізацію при якій відправляється тільки $x$ координата і не витрачати час на її перевірку.

== Застосування еліптичних кривих поза межами ECC

Еліптичні криві можна застосувати у криптографії поза межами ECC:

1. Для факторизації, наприклад алгоритм факторизації Ленстра @ECFact. Він має часову складність $O(exp((sqrt(2) + o(1)) sqrt(log p log log p))(log N ^ 2))$ @ECFactComplexity

2. Для тестування на простоту. Існують, наприклад, тести на простоту Еткіна-Морея(Atkin–Morain elliptic curve primality test) зі складністю $O(log^(6 + epsilon) N)$, для деякого $epsilon > 0$ і алгоритм Голдвошера-Кілана(Goldwasser–Kilian algorithm) зі складністю $O(log^(10 + c_2) N)$, де $c_2$ деяке число більше 0.

Найбільше число, простоту якого було доведено використовуючи еліптичні криві, має 86453 знаків @PrimeRank.

== Висновки 

У цьому розділі було розглянуто і досліджено теоретичний фундамент ECC, а саме: еліптитчні криві над $RR$, еліптичні криві над полями скінченої характеристики $p$, обчислення над точками еліптичних кривих і їх геометрична інтерпретація для еліптичних кривих над $RR$, обчислення кількості точок еліптичної кривої, способи обчислення і оптимізації скалярного добутку точки на ціле число, спарювання точок еліптичної кривої, спеціальні випадки еліптичних кривих (Монгомері, Едвардса, Кобліца), проблему знаходження дискретного логарифма для точок еліптичної кривої і можливі атаки на неї, припущення на яких будується криптографія еліптичних кривих, скручування еліптичних кривих і застосування еліптичних кривих поза межами ECC. Як висновок, з цього розділу має бути очевидно, що розробка своєї еліптичної кривої - це складна справа з великою кількістю нюансів, до того ж, неправильно побудована еліптична крива може призвести до того, що криптосистеми з її використанням не будуть безпечними. Тому на практиці використовують набір затверджених, або просто перевірених кривих. Деякі з них будуть розглянуті у наступному розділі.

#pagebreak()

= ЗАСТОСУВАННЯ У КРИПТОГРАФІЇ

В цьому розділі розглянуто еліптичні криві які використовуються у сучасній криптографії і побудовані на них криптосистеми. Також описується побудова криптосистеми, що використовує еліптичні криві, з нуля, наводяться деякі бенчмарки. Для того, щоб бенчмарки мали більше сенсу, опис оточення в якому вони проводились: процесор Ryzen7 7700X(8 ядер, 16 потоків, частота 4.5Гц - 5.4ГГц), 32Гб оперативної пам'яті DDR5 частотою 6000МГц, операційна система Fedora 37 з версією ядра Linux 6.2.15,
версія OpenSSL 3.0.8, версія libsodium 2.3.

== Кодування інформації за допомогою еліптичних кривих

В ECC публічний ключ, шифротекст і цифровий підпис - це елементи $E(FF_p)$, приватний ключ - це елемет $ZZ_q$.

Тепер розглянемо яким чином кодуються/декодуються точки еліптичної кривої, найрозповсюдженішим стандартом є SEC1 @SEC1. Нехай, у нас є закодована точка $P in E(FF_p)$ в послідовність байт:
- Якщо перший байт 0х00, це означає, що $P = cal(O)$.
- Інакше, якщо перший байт 0х02 або 0х03, це означає, що точка закодована у стисненому форматі (compressed form) (0х02|0x03)||$x$, де $x$ - це $x(P)$. Знаючи $x$ можна обчислити $y^2$ і знайти з нього 2 кореня. 0x02 означає, що треба взяти парний корінь, 0х03 - непарний.
- Інакше, якщо перший байт 0х04, це означає, що точка закодована у форматі 0x04||$x$||$y$ (uncompressed form).
- Інакше цей байтовий рядок відкидається.

== Приклади еліптичних кривих у сучасній криптографії

Розглянемо одні з найрозповсюженіших кривих, що використовуються у сучасній криптографії та надають 128 бітний рівень безпеки.

=== secp256r1 (P256)

Це крива була затверджена NIST в стандарті SEC2 @SEC2 у 1999 році. Це крива є єдиною обов'язковою кривою TLS 1.3. r у назві означає random(випадкова). secp256r1 визаначена наступним чином:
- Крива визначена над $p_r = 2^256 − 2^224 + 2^192 + 2^96 − 1$. Така структура $p_r$ призначена пришвидшити арифметику по модулю $p_r$
- Крива має рівняння у формі Веєрштрасса $y^2 = x^3 - 3x + b,$ де $b in FF_(p_r)$ можна записати у шістнадцятиричному вигляді як $b = "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b"$
- $|E(FF_p)|$ - просте число
- Стандарт також специфікує генератор $g$, який має використовуватись.

Стандарт стверджує, що $b$ було згенеровано публічним детерміністичним генератором випадкових чисел, в якому як seed використовували деяке $S$, значення якого не вказується.
Існує нічим не підтверджена теорія, що $b$ було обрано таким чином, щоб існувала деяка невідома загалу атака на ECDLP для цієї кривої, про яку знає тільки уряд США.

=== secp256k1 (Bitcoin curve)

Ця крива також була затверджена в SEC2. Вона шикоро використовується в блокчейнах, наприклад, ця крива використовується в блокчейнах Bitcoin і Ethereum. secp256r1 визначена наступним чином:

- Крива визначена над $p_r = 2^256 − 2^32 − 2^9 − 2^8 − 2^7 − 2^6 − 2^4 − 1$. Аналогічно secp256r1 така структура $p_r$ призначена пришвидшити арифметику по модулю $p_r$
- Крива має рівняння у формі Веєрштрасса $y^2 = x^3 + 7$. Як нескладно помітити - це крива є кривою Кобліца, що означає, що для неї можна прискорити операцію множення точки на число. k у назві означає Koblitz.
- $|E(FF_p)|$ - просте число
- Стандарт також специфікує генератор $g$, який має використовуватись.

Як можна зазначти, у цієї кривої немає випадкового параметра.

=== Curve25519

Ця крива, на відміну від попередніх не сертифікована NIST. Curve25519 @Curve25519 визначена наступним чином:

- Крива визначена над $p = 2 ^ 255 - 19$, звідки і походить її назва. $p$ - це найбільше просте число меньше $2^255$, що дозволяє прискорити арифметику в $FF_p$
- Крива має рівняння у формі Монгомері $y^2 = x^3 + 486662*x^2 + x$. Також цю криву можна задати у формі Едвардса $x^2 + y^2 = 1 + (121665/121666)x^2 y^2$. Тобто для цієї кривої працюють як і оптимізації для кривих Едвардса, так і оптимізії для кривих Монгомері. $A$ обрано найменшим з можливих щоб прискорити алгоритм сходів Монтгомері, вибір гарно обгрунтовано в @Curve25519.
- Генератором є точка $P = (x, y) " де " x = 9$
- $|E(FF_p) = 8 q, " де " q|$ просте число. Тобто кофактор даної кривої 8.

Також це крива є скручено безпечною (twist secure). Варто зазначити, що всі константи в цій кривій чітко обгрунтовані.

=== bn256

Якщо минулі криві були розроблені для криптосистем на основі ECDLP, то ця крива була розроблена для криптосистем на основі спарювання. Ступінь вкладення(embedding degree) $d = 12$. Додаткову інформацію про цю криву і побудову криптосистем на її основі можна знайти в @bn256.

== Протоколи узгодження ключів

=== ECDH

ECDH(Elliptic curve Diffie-Hellman) - протокол Діффі-Геллмана для еліптичних кривих. Цей протокол використовується для узгодження спільного секрету, на практиці цим спільним секретом є симетричний ключ. Розглянемо сам протокол.

1. Аліса і Боб узгоджують криву $E slash FF_p$ в якій ECDLP складнообчислювальна проблема і точку $P in E(FF_p)$. $P$ має бути або генератором $E(FF_p)$, або підгрупи степені $q$, де $q$ - велике просте число.
2. Аліса і Боб обирають секретні числа $n_A, n_B in ZZ_q$ відповідно, не розголошуючи їх.
3. Аліса обчислює $Q_A = n_A P$, Боб обчислює $Q_B = n_B P$
4. Аліса відсилає $Q_A$ Бобу, а Боб відсилає $Q_B$ Алісі.
5. Аліса обчислює $n_A Q_B = n_A n_B P$. Боб обчислює $n_B Q_A = n_A n_B P$
6. $n_A n_B P$

ECDH виходить з припущення CDH. Варто зазначити, що на практиці точки $Q_A$ і $Q_B$ відсилають у стисненому форматі, оскільки еліптична крива над $n$ бітним простим $р$ має рівень захисту $n slash 2$ бітного cиметричного ключа. Тобто маючи 256 бітну криву можливо домовитись максимум про 128 бітний спільний симетричнмй ключ. Також на практиці 1 крок протоколу пропускається, оскільки він зафіксований у конкретному стандарті. ECDH, що використовує P256, часто позначають ECDH/P256, а ECDH, що використовує Curve25519 - X25519. Порівняємо швидкодію ECDH/P256, X25519 і класичного DH над $ZZ_p ^ *$. Візьмемо DH-2048 щоб він погоджував аналогічно до ECDH/P256 і X25519 128 бітний симетричний ключ. Заміри проводилися за допомогою OpenSSL @OpenSSL - найрозповсюдженішої бібліотеки, що імплементує TLS протокол.

#figure(
  image("resources/dh2048.png"),
  caption: [
    Швидкість роботи DH-2048
  ],
) \

#figure(
  image("resources/ecdhp256.png"),
  caption: [
    Швидкість роботи ECDH/P-256
  ],
) \

#figure(
  image("resources/x25519.png"),
  caption: [
    Швидкість роботи X25519
  ],
) \

#[
  #set par(leading: 0.5em)
  #figure(
    caption: "Порівняльна таблиця швидкодій стандартизацій протоколу Діффі-Геллмана",
    table(
      columns: (auto, auto, auto, auto),
      align: center + horizon,
      inset: 10pt,
      [], [*DР-2048*], [*ECDH/P-256*], [*X25519*],
      [Абсолюта кількість погоджень/c], [53737], [332204], [472399],
      [Відносна кількість погоджень/c], [1], [#calc.round(332204/53737, digits: 1)], [#calc.round(472399/53737, digits: 1)],
    )
  ) <dh-cmp>
] 
\

Як можна побчити з (@dh-cmp) стандарти, що використовують еліптичні криві в протоколі Діффі-Геллмана працють набагато швидше стандартів, що використовують $ZZ_q$. Цей бенчмарк показав приріст швидкості роботи у 6 разів. Варто відзначити швидкість роботи X25519, що побудований на Curve25519. 

== Протоколи підпису і верифікації
Схемою цифрового підпису є трійка $(G, S, V)$, де: $G() arrow.r "sk", "pk"$ - алгоритм генерації приватного і публічного ключа, $S("sk", "m") arrow.r sigma("sign") $ - алгоритм підписання, що по повідомленню і приватному ключу генерує підпис і $V("pk", m, sigma) arrow.r "accept"/"reject"$ - алгоритм верифікації, що по публічному ключу, повідомленню і підпису або підтверджує підпис, або відкидає його.

Приватним ключем у нижченаведених алгоритмах є випадковий елемент $"sk" = ZZ_q*$, публічним є $"pk" = ("sk") * P$. Нехай R() - функція що повертає випадковий елемент з $ZZ_q$, H() - безпечна хеш функція.

#pagebreak()

=== ECDSA
Алгоритм підпису, який, з розглянутих кривих, може бути побудований на secp256r1 та secp256k1, але не на Curve25519:
```
S(sk, m):
  do:
    nonce := R()
    u := nonce * P = (x, y)
    r := reduce x modulo q
    s := (H(m) + r * sk) / nonce
  until r != 0 and s != 0 

  return sig := (r, s)   
```

Алгоритм верифікації:

```
V(pk, m, sign = (r, s)):
  if r = 0 or s = 0
    return reject
  a := H(m) / s
  b := r / s
  u := a * P +  b * pk 
  if u is point at infinity:
    return reject
  let u = (x, y)
  r' = reduce x modulo q
  if r' = r:
    return accept
  else:
    return reject    
```

Для безпеки критично, щоб нонс (nonce) був отриманий випадково і мав рівномірний розподіл. У ситуації, якщо нонс для кожного підпису однаковий, зловмисник може дізнатися приватний ключ. За допомогою такої атаки, наприклад, взламали PlayStation 3.

=== EdDSA

Ed від Edwards curve. Такою кривою з розглянутих є тільки Curve25519. EdDSA простіший за ECDSA. Алгоритм підпису:
```
S(sk, m):
  pk := sk * P
  nonce := H(H(sk) + m)
  r := reduce nonce modulo q 
  R := r * P
  h := reduce H(R + pk + m) modulo q
  s := reduce (r + h * sk) modulo q
  return sign = (R, s)
```
Алгоритм верифікації:
```
V(pk, m, sign = (R, s)):
  h := reduce H(r + pk + m) modulo q
  Q1 := s * P
  Q2 := r + h * pk
  if Q1 = Q2
    reurn accept
  else:
    reject
```

На відміну від ECDSA EdDSA має детерміністичний нонс, з чого слідує, що 2 однакові повідомлення підписані однаковим ключем будуть мати однаковий підпис. У зв'язку з детерміністичністю нонса зникають проблеми недостатньої його випадковості. 

=== BLS

Це підпис який реалізований за допомогою спарювання точок еліптичної кривої. Тут не наводиться докладний опис, з ним можна ознайомитися в @BonehShoup. Зазвичай використовує bn256.

Порівняємо ECDSA і EdDSA. Заміряємо швидкість ECDSA/P-256, Ed25519(EdDSA що використовує Curve25519) та алгоритму що використовуює $ZZ_p ^ *$ DSA-2048:

#figure(
  image("resources/dsa-2048.png"),
  caption: [
    Швидкість роботи DSA-2048
  ],
) \

#figure(
  image("resources/ecdsap256.png"),
  caption: [
    Швидкість роботи ECDSA/P-256
  ],
) \

#figure(
  image("resources/ed25519.png"),
  caption: [
    Швидкість роботи Ed25519
  ],
) \

#[
  #set par(leading: 0.5em)
  #figure(
    caption: "Порівняльна таблиця алгоритмів підпису/верифікації",
    table(
      columns: (auto, auto, auto, auto),
      align: center + horizon,
      inset: 10pt,
      [], [*DSA-2048*], [*Ed25519*], [*ECDSA/P-256*],
      [Абсолюта кількість підписів/c], [6520.3], [40992.4], [79822.8],
      [Відносна кількість підписів/c], [1], [#calc.round(40992.4/6520.3, digits: 1)], [#calc.round(79822.8/6520.3, digits: 1)],
      [Абсолюта кількість верифікацій/c], [7350.2], [14937.6], [25489.4],
      [Відносна кількість верифікацій/c], [1], [#calc.round(14937.6/7350.2, digits: 1)], [#calc.round(25489.4/7350.2, digits: 1)],
    )
  )
]
\

В цих бенчмарках є нюанс в тому, що OpenSSL зорієнтована на оптимізацію P256, через її розповсюдження в TLS 1.3, на відміну від Curve25519. Щоб переконатися у цьому порівняємо швидкість роботи підпису імплементації Ed25519 в OpenSSL і в libsodium @libsodium. Додатково проведемо такий самий бенчмарк для libsecp256k1 @libsecp256k1 ECDSA/secp256k1.

#figure(
  image("resources/openssl_sign_ed25519.png"),
  caption: [
    Швидкість роботи ECDSA/P-256
  ],
) \

#figure(
  image("resources/libsodium_sign_ed25519.png"),
  caption: [
    Швидкість роботи Ed25519
  ],
) \

#figure(
  image("resources/secp256k1_sign.png"),
  caption: [
    Швидкість роботи ECDSA/secp251k1
  ],
) \

Отже, OpenSSL може підписати 2546 повідомлень за мікросекнду, а libsodium 14435, що у 7 разів більше. Тобто можна висунути припущення, що libsodium Ed25519 в 3.5 рази швидший за ECDSA/P-256 OpenSSL. Як можна побачити вже вдруге, криптосистеми реалізовані за допомогою Сurve25519 показують найкращу швидкодію. Також можемо зробити висновок що ECC алгоритми підпису/верифікації перевищують по швидкодії алгоритми підпису/верифікції, що використовують $ZZ_p ^ *$ щонайменше у 3.5 рази.

== Імплементація бібліотеки

Цільовим рівнем безпеки для імплементованої бібліотеки є 256 бітний ключ ECC, який відповідає рівню безпеки симетричного шифрування з 128 бітним ключем. Як було визначено раніше, Сurve25519 має кращі показники швидкодії порівнюючи з P256 та secp256k1. Також, деякі нові блокчейни(наприклад @Monero) створюються з використанням підписів на основі Сurve25519, замість secp256k1, тож можна припустити, що бенчмарки покзали правильний результат і Сurve25519 дійсно має найкращу швидкодію серед описаних у цій роботі кривих. Окрім цього, EdDSA перевершує ECDSA, оскільки EdDSA не потребує недетермінованого генератора випадкових чисел. Також, ECDSA, на відміну від EdDSA, не має властивості ексклюзивного володіння. Це означає, що для заданої пари $(m,s)$, де m - повідомлення, s - підпис нескладно згенерувати нову валідну пару $(m, s')$ @ExclusiveOwnership. Тому бібліотека імплементує криптосистеми саме на Сurve25519.

Для розробки бібліотеки, яка імплементує криптосистеми з використанням еліптичних кривих використаний 23 стандарт мови програмування С++. Імплементація бібліотеки, тести і наведені вище бенчмарки знaходиться за посиланням @ECCPP.

Коректна, швидка і безпечна імплементація самої кривої, а також елементів $FF_p$, дуже складна і часозатратна задача, оскільки неправильна імплементація може призвести до того, що криптосистема на її основі буде вразлива до атак. Тому було вирішено взяти імплементацію елементів $FF_p$ з libsodium. На основі Curve25519 в бібліотеці імплементовано X25519 і Ed25519.

#pagebreak()

#set heading(numbering: none)

= Висновки

У цій роботі грунтовно розглянуто математичні основи криптографії еліптичних кривих: група точок еліптичної кривої над полем скінченої характеристики і обчислення над нею, припущення на яких грунтується криптографія еліптичних кривих та можливі атаки на них, можливі способи оптимізації швидкості роботи криптографічних систем на основі еліптичних кривих.

Як результат дослідження визначено, що крива Curve25519 є найбільш актуальною з розглянутих 256 бітних кривих. Однією з причин є те, що це крива Монтгомері, що дозволяє оптимізувати скалярний добуток точки еліптичної кривої на число. Як доказ, було проведено вимірювання швидкості роботи, які показали що найшвидшим стандартом протоколу Діффі-Геллмана є X25519 побудований на Curve25519. Також було порівнянно схеми цифрового підпису Ed25519 і ECDSA. Було виміряно, що Ed25519 має кращу продуктивність. Додатково серед переваг EdDSA є детермінованість, що дозволяє не залежати від наявності недетермінованого генератору випадкових чисел у системі, і ексклюзивне володіння підписом.

Було розроблено бібліотеку мовою С++, що імплементує протоколи Ed25519 і X25519.

Дослідження, проведені у цій роботі, можуть бути використані розробниками, які обирають алгоритми підпису і погодження ключів для розробки нової системи, або для вдосконалення існуючих

#pagebreak()
 
= Перелік джерел посилання
#bibliography(title: none, "sources.yml")