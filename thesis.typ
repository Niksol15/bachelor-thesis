#let fontsize = 14pt
#show heading: set text(size: fontsize)
#show heading.where(level: 1): it => align(center)[#upper(it) \ ]
#set text(size: fontsize, font: "Times New Roman", lang: "ua")
#show raw: set text(size: fontsize)
#show raw: set par(leading: 0.5em)
#show math.equation: set text(size: 14pt)
#show "CAL_O": $cal(O)$
#set page(
  paper: "a4",
  margin: (
    top: 20mm,
    bottom: 20mm,
    left: 25mm,
    right: 10mm
  ),
  header: align(right)[#counter(page).display(i => if i != 1 [#i])]
)

#align(center)[
  *КИЇВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ \
  ІМЕНІ ТАРАСА ШЕВЧЕНКА* \
  Факультет комп’ютерних наук та кібернетики \
  Кафедра математичної інформатики \ \ \
  *Кваліфікаційна робота \
  на здобуття ступеня бакалавра* \
  за освітньо-професійною програмою “Інформатика” \
  спеціальності 122 Комп'ютерні науки на тему: \ \
  *ІМПЛЕМЕНТАЦІЯ КРИПТОСИСТЕМ НА ОСНОВІ ЕЛІПТИЧНИХ КРИВИХ* \ \ \
]

#let signature = [
  \
  #line(length: 100%)
  #align(center, text(size: 0.8em, "(підпис)"))
]

#grid(
  columns: (70%, 30%),
  [
    Виконав студент 4-го курсу \
    Нікіта СОЛОНКО
  ],
  signature,
  [
    \
    Науковий керівник: \
    Член-кореспондент НАН України, професор \
    Анатолій АНІСІМОВ
  ],
  [\ \ #signature],
)

\ \
#grid(
  columns: (40%, 60%),
  [],
  [
    Засвідчую, що в цій роботі немає запозичень з
    праць інших авторів без відповідних посилань.

    #grid(
      columns: (50%, 50%),
      align(center)[\ Студент],
      signature,
    )
  ]
)

#align(center + bottom)[Київ -- 2023]
#pagebreak()

#heading(outlined: false)[Реферат]

Обсяг роботи:
#locate(loc => counter(page).final(loc).at(0)) сторінок,
#locate(loc => counter(figure.where(kind: image)).final(loc).at(0)) ілюстрацій,
#locate(loc => counter(figure.where(kind: table)).final(loc).at(0)) таблиць,
#locate(loc => counter(ref).final(loc).at(0)) використаних джерел.

TBD.

#pagebreak()

#outline()

#pagebreak()

= Скорочення та умовні позначення

/ ECC: Elliptic curve cryptography;
/ EC: Elliptic curve;
/ SIMD: Single instruction multiple data;
/ DLP: Discrete Logarithm Problem, задача дискретного логарифму;
/ GNFS: General Number Field Sieve;
/ CDH: Computational Diffie–Hellman assumption;
/ DDH: Decisional Diffie–Hellman assumption;

#pagebreak()

#let leading = 18pt
#set par(leading: leading, first-line-indent: 1.27cm,)
#show par: set block(spacing: leading)
#show outline: set par(first-line-indent: 0mm)
#show terms: set par(first-line-indent: 0mm)

= Вступ

*Оцінка сучасного стану об’єкта дослідження* 

На даний момент, окрім того, що застосування еліптичних кривих у криптографії активно досліджується в академічних роботах, існує безліч прикладних
реалізацій ECC, що використовуються повсюдно. Більш того, криптосистеми з відкритим ключем, що використовують еліптичні криві, потроху стають
популярнішими за, найбільш розповсюджений зараз, RSA. Так, наприклад, нові версії ssh рекомендують використовувати ключі Ed25519, що побудовані
на еліптичних кривих Едварда, замість RSA. Аналогічні рекомендації зараз дають такі сервіси як: GitLab, GitHub, Amazon Web Services, Google
Cloud Platform і багато інших.

*Актуальність роботи та підстави для її виконання*

Як було зазначено раніше, криптосистеми з відкритим ключем побудовані на основі еліптичних кривих вже активно використовуються, але все ще 
перебувають у стані активного розвитку. Так, наприклад, стаття @EdDSA в якій була запропонована одна з найбільш популярних зараз еліптичних
кривих Ed25519 і алгоритм підпису/верифікації на її основі EdDSA була написана в 2012 році, що для криптографії недавно. Також зараз 
існує багато програмних реалізацій таких криптосистем, але, у зв’язку зі складністю їх імплементації, не всі вони є цілком безпечними. Варто
зазначити, що  з кожним роком архітектура обчислювальних систем розвивається: оптимізуються існуючі інструкції та додаються нові, що відкриває
можливості як для оптимізації існуючих реалізацій, так і для написання нових - кращих. Наприклад, в архітектурі x64 апаратна підтримка SIMD
обчислень з 512 бітними регістрами AVX-512 з’явилася в 2013 році, вже після виходу статті з описом Ed25519.


*Мета й завдання роботи*

Метою роботи є дослідження застосування еліптичних кривих у сучасній криптографії, і як результат дослідження імплементувати криптографічну
бібліотеку для роботи з еліптичними кривими та порівняти її з існуючими реалізаціями.

*Можливі сфери застосування*

Оскільки програмна реалізація яку я розроблю у рамках цієї роботи не буде сертифікована, то її не варто буде застосовувати в реальних
системах на які може бути здійснена атака, але вона може бути застосована у навчальних і академічних цілях. В перспективі така бібліотека
може бути застосована всюди де потрібна безпечна комунікація, в умовах коли можливе прослуховування, або втручання в  канали зв’язку, між
сутностями які ще не узгодили симетричний ключ. Наприклад: TLS, HTTPS і так далі. 

#pagebreak()

#set heading(numbering: (..nums) => {
  if nums.pos().len() == 1 {
    "Розділ " + str(nums.pos().at(0)) + "."
  } else {
    numbering("1.", ..nums)
  }
})

= ЕЛІПТИЧНІ КРИВІ
== Переваги над $ZZ_p^*$
\

Під $ZZ_p^*$ мається увазі мультиплікативна група лишків за модулем p, де p - просте число.

Розглянемо мотивацію використання нового криптографічного примітиву, коли вже побудовано і імплементовано багато криптосистем на основі
$ZZ_p^*$, таких як: Diffie-Hellman, ElGamal, RSA і багато інших. Проблема використання таких криптосистем полягає у тому, що вони були 
запропоновані давно: Diffie-Hellman @DH - 1976, RSA @RSA - 1978, ElGamal @ElGamal - 1985. З того часу кратно збільшились обчислювальні
можливості. Частота ядер виросла з кГц до ГГц, кількість ядер збільшилась з одиниць до сотень, з’явилися зручні інструменти для об’єднання
процесорів у кластери. Також, через бажання зламати дані криптосистеми, багато вчених шукали спосіб знайти більш  ефективні алгоритми
розв'язання проблем на які вони спираються. Таким чином у 1993 Ленстра @GNFS придумав ефективний алгоритм розкладання великих чисел на
множники - GNFS(General Number Field Sieve), який може розкласти число $n > 10^100$ за час:
$ exp( ((64/9) ^ (1/3) + o(1)) (log n) ^ (1/3) (log log n) ^ (2/3)) $
Це стало основною проблемою криптосистем на основі $ZZ_p^*$, тому що він робить вирішення обчислювальних проблем, на які спираються ці
криптосистеми субекспоненційним, замість експоненційних. Варто зазначити, що цей алгоритм не є чисто теоретичною загрозою. За його 
допомогою у 2019 році @BonehShoup було знайдено дискретний логарифм 795 бітного числа. Таким чином, в патенті RSA @RSA рекомендований 
розмір ключів був 200біт, в першій NIST сертифікації - 512 біт, зараз же мінімальний рекомендований розмір - 2048 біт. Важливим також є те,
що GNFS неможливо узагальнити на будь-які скінчені циклічні групи, тому він не зачіпає групу точок еліптичної кривої над скінченним полям
(позначення буде наведено далі), по цій причині найкращий відомий алгоритм для вирішення проблеми дискретного логарифма для групи точок 
еліптичних кривих (ECDLP) займає час $O(sqrt(q))$, де q - розмір групи. Через це розміри ключів що мають однакову безпеку для $Z_p ^ *$ і для 
групи точок кліптичної кривої сильно відрізняються. Порівняльна характеристика безпеки ключа в залежності від розміру ключа RSA/Diffie-Hellman
і ECC:

#figure(
  image("resources/key-size-comparison.jpg"),
  caption: [
    @KeyCmpImg
  ],
) \

Як можна побачити з наведеної таблиці використання еліптичних кривих дає вагому перевагу, оскільки зменшує розмір ключа, що в свою чергу
зменшує час потрібний на проведення операцій з ключем (що дає виграш у швидкодії), кількість затраченої енергії (що є вагомою перевагою для 
IoT), навантаження на мережу під час передачі ключа і загалом трафік.

Ще однією перевагою криптографії еліптичних кривих є те, що можна використати багато напрацювань з криптографії з відкритим що використовує
$ZZ_p^*$. Оскільки ECC як складно обчислювальну проблему використовує знаходження дискретного логарифма - DLP(у випадку еліптичних кривих 
вживають термін ECDLP), аналогічно до складно обчислювальної проблеми в Diffie-Hellman і ElGamal. До того еліптичні криві мають додаткову
структуру, яку не має $ZZ_p ^ *$, що дозволяє побудувати неможливі для $ZZ_p ^ *$ криптосистеми. Такою додатковую структурою є можливість 
будувати pairing(спарювання точок еліптичних кривих), lattices(алгебраїчні решітки), isogenies(ізогенії). Алгебраїчні решітки і ізогенії
еліптичних кривих зараз активно використовуються для побудови пост-квантових криптосистем з відкритим ключем.


== Загальний огляд еліптичних кривих
\

=== $E slash RR$
\

Існує декілька форм задання еліптичних кривих. Почнемо з найбільш класичної:

Еліптичною кривою $E$ називається множина точок, що є розв'язком рівняння: $y^2 = x^3 + a*x + b$.

Наведене рівняння називають рівнянням Веєрштрасса і, відповідно, дану форму задання еліптичної кривої називають формою Веєрштраса.
Якщо еліптична крива задана над полем $FF$, будемо позначати це як $E slash FF$

#figure(
  image("resources/EC-example.png"),
  caption: [
    Ілюстрація 2 еліптичних кривих з @MathCrypto
  ],
) \

Еліпітичні криві є не просто об'єктом вивчення аналітичної геометрії, а й цікавим об'єктом розгляду алгебри, бо над точками еліптичної кривої можна проводити обчислення. 
Перед переходом до еліптичних кривих над скінченими полями, для більш інтуітивного розуміння, розглянемо як "додавати" точки
еліптичної кривої над $RR$, бо це можна легко інтерпретувати геометрично. Позначемо операцію додавання точок еліптичної кривої як $plus.circle$ і розглянемо її на 
прикладі з @MathCrypto. 

Для початку визначимо, що якщо $A = (x, y) in E text(", то") -A = (x, -y) in E$. Нехай $E slash RR$ - це еліптична крива задана рівнянням $y^2 = x^3 - 15x + 18$; 
Точки $P = (7, 16), Q = (1, 2) in E$, тоді пряма $L$ що їх сполучає задається рівнянням: $y = 7/3 x - 1/3$. Для того щоб знайти в яких точках $L$ перетинає $E$ 
ми можемо підставити заміcть $y$ рівність з $L$ в $E$ і розв'язати рівняння відносно $x$. Для наведеного прикладу маємо:

$(7/3 x - 1/3) ^ 2 = x^3 -15 x + 18 arrow.r x^3 - 49/9 x^2 - 121/9 x + 161/9 = 0$

Отримане рівняння є рівнянням третьої степені, отже воно має 3 корені, 2 з яких нам вже відомі, залишається знайти третій корінь. Найлегшим способом є поділити отриманий поліном на 
$(x - 7)(x - 1)$. Таким чином отримуємо третій корінь $x = -23/9$. Підставляючи $x$ в $E$ отримуємо $y = -170/27$, а отже точку $R = (-23/9, -170/27)$. 
Далі відображаємо $R$ відносно OX:

$P plus.circle Q = -R = R' = (-23/9, 170/27)$

Цей метод називається методом хорди. Наведене вище в графічно:

#figure(
  image("resources/P_plus_Q.png"),
  caption: [
    $P plus.circle Q$ з @MathCrypto
  ],
) \

Розглянемо випадок $P plus.circle P = 2P = R'$. Для цього проведемо дотичну до $E$ в точці $P$. Для цього потрібно діференціювати $E$ по $x$. На прикладі, який розглядався раніше:

$2y (dif y)/(dif x) = 3 x^2 -15 arrow.r (dif y) / (dif x) = (3 x^2 - 15) / (2 y)$

Підставляючи координати $P = (7, 16)$ отримуємо $L: y = 33/8 x - 103/8$. Аналогічно попередньому прикладу знаходимо $R = (193/64, -223/512)$, а отже 

$P plus.circle P = R' = -R = (193/64, 223/512)$

Цей метод називається методом дотичної. Наведене вище в графічно:

#figure(
  image("resources/P_plus_P.png"),
  caption: [
    $P plus.circle P$ з @MathCrypto
  ],
) \


Залишиось розглянути останній випадок: $P plus.circle (-P)$. Для цього введемо спеціальну точку, що називається точкою на нескінченості: $cal(O)$, 
тоді $P plus.circle (-P) = cal(O)$. Графічно це виглядає наступним чином:

#figure(
  image("resources/P_minus_P.png"),
  caption: [
    $P plus.circle (-P) = cal(O)$ з @MathCrypto
  ],
) \

Формальний кінцевий алгоритм, що покриває всі вищенаведені випадки, буде наведено у наступному підрозділі.

=== $E slash FF_p$
\ 

Перейдемо до еліптичних кривих що застосовуються у криптографії - еліптичних кривих над скінченимими полями.
Почнемо з визначення:

Нехай $p > 3$ - простe число. Тоді еліптичною кривою $E$ визначеною над $FF_p$ є множина розв'язків рівняння $y^2 = x^3 + a*x + b$, де $a, b in FF_p$ задовільняють умову 
$4 a^3 + 27 b^2 eq.not 0$. Ця умова потрібна щоб впевнитись, що рівння $x^3 + a x + b = 0$ має тільки один корінь. У випадку, якщо попередня властивість не виконується, 
рівняння кривої буде мати 2, або 3 однакових кореня. Нехай у такому випадку коренем рівняння кривої буде $x_0$, тоді точка $(x_0, 0)$ називається сингулярною, і 
відповідна крива теж називається сингулярною.

Множиною точок еліптичною кривої $E slash FF_p: y^2 = x^3 + a x + b; a, b in FF_p$ є $E(F_p) = {(x, y): x, y in FF_p and y^2 = x^3 + a x + b} union {cal(O)}$. 

Розглянемо приклад. Нехай $E: y^2 = x^3 + 1$ визначена на $FF_(11)$, тоді: 
$E(FF_(11)) = { cal(O), (−1, 0), (0, plus.minus 1), (2, plus.minus 3), (5, plus.minus 4), (7, plus.minus 5), (9, plus.minus 2)}$

Тепер розглянемо $plus.circle$ для $E(FF_p)$. Для цього будемо спиратися на результати розгляду $(E(RR), plus.circle)$, бо для $E(FF_p)$ алгоритм виглядає аналогічно 
до алгоритму для $E(RR)$, але його не вдасться легко інтерпретувати геометрично. Розглядом геометричної інтерпретації обчислень над точками еліптичних кривих над 
скінченими полями займається алгебраїчна геометрія і це виходить за межі даної роботи. Нехай $P = (x_p, y_p) or cal(O), Q = (x_q, y_q) or cal(O) in E(FF_p)$:
- Якщо $P = cal(O) arrow.r P plus.circle Q = Q$
- Інакше, якщо $Q = cal(O) arrow.r P plus.circle Q = P$
- Інакше, якщо $Q = -P arrow.r P plus.circle Q = cal(O)$ (варто зазначити що це покриває випадок коли $y_p = y_q = 0$)
- Інакше, якщо $P = Q$ використовуємо метод дотичної: $lambda = (3x_p + a) / (2y_p)$
- Інакше використовуємо метод хорди: $lambda = (y_q - y_p) / (x_q - x_p)$
- $x = lambda ^ 2 - x_p - x_q; y = lambda(x_p - x) - y_p arrow.r P plus.circle Q = (x, y)$

$(E(FF_p), plus.circle)$ утворюють циклічну абелеву групу.

Наведений вище алгоритм для еліптичних кривих загального вигляду має 2 основних недоліки:
+ Він не є достатньо швидким, як буде розглянуто далі існують спеціальні види еліптичних кривих, для яких його можна прискорити
+ Імплементація додавання точок еліптичної кривої має працювати за константний час, інакше можлива атака що викриває приватний ключ. Як можна побачити,
даний алгоритм важко реалізувати таким чином, щоб він працював за константиний час через різну кількість обчисленнь за різних умов.

Властивість, коли алгоритм обчислення $plus.circle$ має єдину формулу для усіх точок в $E(FF_p)$ при будь яких умовах, тобто може бути імплементований без умовних операторів, називається complete addition law(повний закон додавання).

== Додаткові обчислення в $E(FF_p)$
=== $|E(FF_p)|$
Однією з найважливіших характеристик еліпитичної над скінченим полем є $q = |E(FF_p)|$ - розмір групи. Стосовно цієї характеристики існує теорема Hesse(Гассе):

Нехай $E slash FF_(p^e)$, тоді: $|E(FF_(p_e))| = p^e + 1 - t_(p^e); t_(p^e) lt.eq 2 sqrt(p^e)$ - називається слідом Фробеніуса.

Важливим є здатність точно обчислити $|E(FF_(p_e))|$. Вперше ефективний алгоритм запропнував Schoof в @Schoof, потім Elkies і Atkin запропонували поліпшення
складності роботи цього алгоритму @SEA. Результат називається SEA, він залишається найшвидшим алгоритмом до цього часу і має складність 
$O(log^2 p * M(log^2 p) slash log log p)$, де $M(n)$ - складність множення.

=== Обчислення $n P$

Більшість ECC криптосистем використовують обчислення $n P, P in E(FF_p)$. Для того щоб ці системи було можливо використовувати у реальному світі це обчислення має бути швидким. Спочатку визначимо формально, що

$P in E(FF_p), n gt.eq 1 in NN: n P = (n - 1) P plus.circle P$

Очевидний приклад: $3P = P + 2P = P + P + P$. Також зрозуміло що обчислювати $n P$ наївно, за $n - 1$ додавань - неоптимально, тому використовують оптимізації:

*Double-and-Add(подвоюй-і-додавай)*.
З її допомогою можна обчислити $n P$ за не більше ніж $2 log_2 n$ додавань. Існують 2 версії цього алгоритму: яка використовує інверсію($P -> -P$) і яка не використовує. Варто відзначити, що знаходження точки еліптичної кривої оберненою до даної - тривільне і швидке, і перша версія для випадковго $n$ потребує меншу кількість операцій у середньому. Приклад реалізації другого варіанту з використанням псевдокоду:

```
Double-and-Add(P, n):
  Q := P
  R := CAL_O
  while n > 0:
    if n ≡ 1 (mod 2):
      R := R + Q
    Q := 2 * Q
    n := n / 2
  return R
```

На практиці, якщо потрібно обчислити, наприклад, $947 P$ першим методом буде обчислено:

$947 P = P plus.circle 2 P plus.circle (-2^4 P) plus.circle (-2^6 P) plus.circle 2^10 P$

#par(first-line-indent: 0cm)[А другим:]

$ 947 P = P plus.circle 2 P plus.circle 2^4 P plus.circle 2^5 P plus.circle 2^7 P plus.circle 2^8 P plus.circle 2^9 P$

Недоліком цього алгоритму є те, що час його роботи залежить від значення $n$. Це робить його вразливим до timing attack. 

*Montgomery ladder(Сходи Монтгомері)*. 
Цей алгоритм має аналогічну часову складіність до алгоритму Double-and-Add, але його перевагою є те, що час його роботи залежить від кількості бітів в $n$, а не від самого значення, що робить його невразливим до timing-attack при умові якщо $plus.circle$ також не вразлива до неї. Сам алгоритм @MontLadder, нехай $n = (n_(t-1),...,n_0)_2$, кількість бітів в $n = t$ позначимо $n[i] = n_i$:

#pagebreak()

```
MontgomeryLadder(P, n):
  R := CAL_O
  Q := P
  for i = t - 1 downto 0:
    if n[i] = 0:
      Q := Q + R
      R := R + R
    else:
      R := R + Q
      Q := Q + Q
  return R       
```

Нехай $x(P), P in E(FF_p)$ - $x$ координата точки $P$. Також, модифікація наведеної імплементації цього алгоритму дозволяє обчислити $x(n P)$ знаючи тільки $x(P)$, використовуючи наступні формули:

$text("Якщо ") (2 alpha) P != cal(O): x_(2 alpha) = 1/4 ((x_alpha ^ 2 - a) ^ 2 - 8 b x_alpha) slash (x_alpha ^ 3 + a x_alpha +b)$

$text("Якщо ") (2 alpha + 1) P != cal(O): x_(2 alpha + 1) = ((a - x_alpha x_(alpha + 1)) - 4 b (x_alpha + x_(alpha + 1))) slash (x_1 (x_alpha - x_(alpha + 1) ^ 2))$

Як висновок, можна резюмувати, що швидкість обчислення $n P$ є важливою характеристикою еліптичної кривої. Існують криві, для яких можна оптимізувати як одиничну операцію $P + Q$, так і обчислення $n P$ в цілому.

=== Дискретний логарифм в $E(FF_p)$

Нехай $E$ - еліптична крива, $FF_p$ - скінчене поле, $P in E(FF_p), Q in angle.l P angle.r$, тоді дискретним логарифмом $Q$ за основою $P$ є таке $n$, що 
$Q = n P$ і позначається $n = log_P Q$.

Нехай $q$ - порядок $P$, тоді очевидно що, якщо $Q = n_0 P$, то $Q = (n_0  + i q) P, forall i in NN$. Для визначеності будемо вважати, що дискретний логарифм - 
це найменше таке $n$, що $Q = n P$. У такому випадку зрозуміло, що $log_P(Q) in ZZ_q$.

Важливо відмітити, що для дискретного логарифму точок еліптичної кривої виконується властивість звичайного логарифму:

$log_P(Q_1 + Q_2) = log_P(Q_1) + log_P(Q_2), forall Q_1, Q_2 in angle.l P angle.r$

З цього випливає, що $log_P$ визнчає груповий гомоморфізм:

$log_P: angle.l P angle.r arrow.r ZZ_q$

Зазвичай на практиці $P$ вибирається з генераторів $E(FF_p)$.

ECDLP - проблема знаходження дискретного логарифму для точок еліптичної кривої.

== Pairing(Спрарювання точок еліптичної кривої)

$E slash FF_p$ має додаткову структуру - pairing. Вона може бути використана для побудови криптосистем неможливих для циклічних груп у загальному випадку, а також 
для $ZZ_p^*$ і дозволяє розширити множину криптосистем ECC. Зазвичай у визначенні використовують мультиплікативні групи, замість адитивних, але оскільки ця робота сконцентрована
саме на еліптичних кривих, то:

Нехай $GG_0, GG_1, GG_T$ - циклічні групи порядку $q$, де $q$ - просте. $g_0 in GG_0, g_1 in GG_1$ - генератори. Pairing - це ефективно обчислювальна функція $e: GG_0 times GG_1 arrow.r GG_T$, яка задовільняє наступні вимоги:

1. Білінеарність. $forall u, u' in GG_0, forall v, v' in GG_1$:

$e(u + u', v) = e(u, v) e(u', v) and e(u, v + v') = e(u, v) e(u, v')$

2. Недегенаривність: $g_T = e(g_0, g_1)$ - генератор в $GG_T$

Коли $GG_0 = GG_1$ назвемо це спарювання симетричним, інакше - асиметричним.
$GG_0, GG_1$ називаються pairing groups, а $GG_T$ - target group(цільовою групою).

З білінеарності випливає основна властивість спарювання, яка використовується в побудові криптосистем:

$forall alpha, beta in ZZ_q: e(g_0 ^ alpha, g_1 ^ beta) = e(g_0, g_1) ^ (alpha beta) = e(g_0 ^ beta, g_1 ^ alpha)$

Вимога недегенеративності потрібна щоб $e$ не повертала завжди $1 in GG_T$ для всіх аргументів.

Найбільш зручним і ефективним спрарюванням для $E slash FF_p$ - є асиметричне спарювання. Спрарювання сконструйоване з $E slash FF_p$ має групи $GG_0, GG_1,GG_T$ з наступними властивостями:

- $GG_0$ - це підгрупа $E(FF_p)$ порядку q, де q - просте.
- $GG_1$ - це підгрупа $E(FF_(p^d))$ порядку q, для деякого $d in NN > 0$, де $GG_0 sect GG_1 = {cal(O)} $
- $GG_T$ - це мультиплікатитвна група 

Число $d in NN$ називається embedding degree(ступіню вкладенння) кривої. Зрозуміло, для того що спарювання було ефективним $d$ має убти малим, тому що, якщо $d$ буде великим ми не зможемо записати елемменти в $GG_1$ та $GG_T$. Еліптитчні криві, де спарювання мале, наприклад $d lt.eq 16$, називають pairing friendly elliptic curves(еліптичними кривими дружніми для спарювання).

Оригінально почали використовувати Weil pairing(Спарювання Вейля). Нехай $m in NN, P in E: m P = cal(O)$. Точка $P$ є точкою скінченого порядку на еліптичній кривій, або torsion points(торсіонною точкою). Більш точно кажуть, що $P$ є точкою порядку m. Позначимо множину точок порядку m як:

$E(FF_p)[m] = {P in E(FF_p): m P = cal(O)}$

Тоді, нехай $f_P, f_Q$ - раціональні функції над $E$(не наводжу тут визначення, ознайомитися з цією концепцією можна в @MathCrypto, @ECNTC), такі що: $text("div")(f_P) = m[P] - m[cal(O)], text("div")(f_Q) = m[Q] - m[cal(O)]$, тоді Wei pairing це:

$e_m(P, Q) = (f_P(Q + S))/(f_P(S)) slash (f_P(P - S))/(f_P(-S)), text(", де") S in E, S in.not {cal(O), P, -Q, P - Q}$

Для побудови Weil pairing існує ефективний Miller's algorithm @MillerAlgo(Алогоритм Міллера). Але на практиці зараз використовують Tate pairing та Ate pairing, оскільки алгоритм Міллера для них ефективніший.


== Спеціальні види еліптичних кривих

=== Montgomery Curve(Крива Монтгомері)

Еліптична крива $E slash FF_p$ у формі Монгомері у зміних $u, v$ має вигляд:

$B v^2  = u ^ 3 + A u^2 + u; A, B in FF_p, B(A^2 - 4) != 0$

Це рівняння кривої може бути легко приведено до рівняння Веєрштрасса заміною  зміних: $u = B x - A/3; n = B y$. Цікавою особливістю кривої Монгомері є те, що $|E(FF_p)|$ завжди ділиться на 4. З цього також випливає, що не кожну криву у формі Веєрштраса можна привести до кривої у формі Монтгомері заміною зміних.

Криві Монгомері дозволяють пришвидшити операцію додавання, шляхом оптимізації Montgomery ladder. Нехай $X_1 = x(P), Z_1 = 1$, і:

$X_(2 alpha) = (X_alpha ^ 2 - Z_alpha ^2)^2$

$Z_(2 alpha) = 4 X_alpha Z_alpha(X_alpha^2 + A X_alpha Z_alpha + Z_alpha ^ 2)$

$X_(2 alpha + 1) = 4Z_1(X_alpha X_(alpha+1) − Z_alpha Z_(alpha+1)) ^ 2$

$Z_(2 alpha + 1) = 4X_1(X_alpha Z_(alpha+1) − Z_alpha X_(alpha+1)) ^ 2$

Тоді $x(alpha P) = X_alpha slash Z_alpha$, якщо $alpha P != cal(O)$

=== Edwards Curve(Крива Едвардса)

Еліптична крива $E slash FF_p$ формі Едвардса має вигляд:

$x^2 + y^2 = 1 + d x^2 y^2, d != 0,1 in FF_p$

Аналогічно кривій Монтгомері, крива Едвардса може бути приведена до форми Вейерштраса заміною зміних, але не навпаки. $|E(FF_p)|$ завжди ділиться на 4. Перевагою кривих Едвардса є те, що $plus.circle$ дуже просто імплементувати:

$forall P, Q in E(FF_p): P plus.circle Q = ( (x_1 y_2 + x_2 y_1) / (1 + d x_1 x_2 y_1 y_2), (y_1 y_2 - x_1 x_2) / (1 - d x_1 x_2 y_1 y_2))$

Для цього визначемо $cal(O) = (0, 1)$. Як можна побачити криві Едвардса мають complete addition law.

=== Koblitz Curve(Крива Кобліца)

Оригінально крива була запропонована Кобліцом над $FF_2$ і мала вигляд:

$E: y^2 + x y = x^3 + a x^2 + 1, a in {0, 1}$

Далі, почалося дослідження цієї кривої над $FF_(2^m)$, вона має вигляд:

$y^2 + x y = x^3 + a x^2 + b, b != 0$

Але, оскільки на практиці частіше застосовують криві цього виду над $FF_p$, і дана робота зосересереджена на $E slash FF_p$, сконцентруємося саме на кривих Кобліца над $FF_p$. Крива Кобліца $E$ над $FF_p$ задаєтсья рівнянням @KoblitzOverP :

$E: y^2 = x^3 + b, p ident 1 (mod 3)$

В більш широкому розуміні кривими Кобліца називають еліптичні криві для яких існує ефективно обчислювальний нетривіальний ендоморфізм $phi.alt: forall P, Q : phi.alt(P + Q) = phi.alt(P) + phi.alt(Q)$, який дозволяє оптимізувати операцію множення точки на число. Для $E(FF_(2^m))$ використовують ендоморфізм Фробеніуса: $phi.alt: FF_(p^k) arrow.r FF_(p^k), alpha arrow.r alpha ^ p$. Застосовуючи його для $E slash FF_(2^m)$ отримуємо $ P = (x,y) in E(FF_(2^m)), phi.alt(x,y)=(x ^ 2,y ^ 2)$. Для $E slash FF_p$ використовують енфоморфізм $phi.alt(x, y) = (omega x, y), 1 != omega in FF_p, omega ^ 3 = 1$. Зрозуміло що таке $omega$ знайдеться, оскільки $p ident 1(mod 3)$, що означає, що 1 має 3 кубічних кореня: $1, u, u^2 (u in FF_p)$. 

Легко перевірити, що якщо $(x, y) in E(FF_p)$, то і $phi.alt(x, y) = (omega x, y) in E(FF-p)$, оскільки $y ^ 2 = x^3 + b = (omega x)^3 + b = omega^3 x^3 +b = x^3 + b$. Також додатково визначемо, що $phi.alt(cal(O)) = cal(O)$. Тобто, доведно, що $phi.alt: E(FF_p) arrow.r E(FF_p)$.

Нехай $q = |E(FF_p)|$. Оскільки, $phi.alt$ є ендоморфізмом і $E(FF_p)$ - циклічна група, має існувати таке $lambda in ZZ_q$, що: $forall P in E(FF_p): phi.alt(P) = lambda P$. Можливо визначити $lambda$ настпупним чином. Очевидно що $P, phi.alt(P), phi.alt ^ 2 (P)$, мають однакову $y$ координату, а отже знаходяться на одній прямій, до того ж горизонтальній. З геометричної інтерпретації $plus.circle$ відомо, що це означає, що їх сума $cal(O)$, отже:

$forall P in E(FF_p): cal(O) = P plus.circle phi.alt(P) plus.circle phi.alt ^ 2(P)= P plus.circle lambda P plus.circle lambda ^ 2 P = (1 + lambda + lambda^2) P$

Звідки можемо зробити висновок, що
$1 + lambda + lambda ^ 2 = 0 arrow.r (lambda - 1)(1^2 + 1 * lambda + lambda^2) = 0 * (1 - lambda) arrow.r lambda^3 - 1 = 0 arrow.r lambda^3 = 1$

Тобто $lambda$ аналогічно до $omega$ це один з двох нетривіальних кубічних коренів 1.

Тепер розглянемо як $phi.alt$ може допомогти в прискорені обчислення $n P$. Нехай $n in ZZ_q$ і ми хочемо обчислити $n P$ для деякого $P in E(FF_p)$. Для більшості таких $n$ можливо знайти такі $tau_0, tau_1, tau_2 in ZZ$, що:

$n = tau_0 + tau_1 lambda + tau_2 lambda ^ 2 and |tau_i| lt.eq 2 q ^(1/3) text("для") i = 0, 1, 2$

Тобто, $n P = tau_0 + tau_1 phi.alt(P) + tau_2 phi.alt ^ 2(P)$

Така оптимізація дозволяє прискорити операцію множення у 2-3 рази @BonehShoup в порівнянні з Double-and-Add.

== Припущення на яких будується ECC
=== ECDLP
Основне припущення ECC полягає у тому, що ECDLP для точок еліптичної кривої над скінченим полем є 
складнообчислювальною проблемою, тобто не існує ефективного алгоритму обчислення дискретного логарифму.

На ECDLP існує багато атак - ефективних алгоритмів розв'язання. Ним присвячена ціла глава в @ECNTC. Нехай $P, Q in E(FF_p), |E(FF_p)| = q$. Перша група атак працює для будь якої циклічної групи:
- Baby Step, Giant Step. Має часову складність $O(sqrt(q))$ і потребує $O(sqrt(q))$ місця. Цей алготирм є детерміністичним
- Алгоритми $rho$ і $lambda$ Полларда. $rho$ є узагальненням $lambda$ алгоритму. Вони також мають часову складність $O(sqrt(q))$, але є потребують тільки $O(1)$ додаткового місця.
- The Pohlig-Hellman method @PohligHellman(Метод Поліга-Геллмана). Ефективний якщо $q$ не є простим і в його факторизації нема великих прочтих чисел. Нехай $q = product_i p_i ^ e_i$, тоді складність часова складність цього алгоритму $O(sum_i e_i(log q  + sqrt(p_i)))$

Такж існує група атак, що використовують pairing, вони в деяких є більш ефективними ніж атаки на циклічні групи. Такими атаками є:
- MOV(Menezes, Okamoto and Vanstone) @MOV. Ця атака використовує Weil pairing щоб звести ECDLP в $E(FF_p)$ до DLP в $FF_(p ^ m)$ 
- The Frey-Rück Attack @FrayRuck (Атака Фрея-Рюка). Аналогічно MOV, тільки використовується більш ефективне Tate pairing.

Оскільки ECC грунтується на припущені про обчислювальну складність ECDLP і ECC активно використовується в реальних криптосистемах можна припустити, що для будь якої 
кривої $E slash FF_p$, де $p$ - достатньо велике просте число ECLP складнообчислювальне, але це є хибним твердженням, у тому числі через наведені до цього атаки, наприклад:

- Якщо $|E(FF_p)|$ не є простим і всі прості множники у його розкладі менші деякого $q_max$, то тоді ми можемо застувати атаку з викристанням метода Поліга-Геллмана. Зокрема, якщо $q_max lt 2 ^ 80$, то ECDLP не є складнообчислювальною проблемою на практиці. Тому в реальних системах використовують криві $E slash FF_p$ для яких $|E(FF_p)|$ рівне $q, 4q, " або " 8q$ для деякого простого $q$.  

- Якщо $|E(FF_p)| = p$, то ECDLP для $E(FF_p)$ розв'язний за поліноміальний час. Такі криві називаються аномальнимим і не використовуються на практиці

- Нехай існує таке мале $tau > 0 in NN$, що $|E(FF_p)|$ ділить $p^tau - 1$. Тоді ECDLP в $E(FF_p)$ можна звести до DLP в $FF_(p^tau)$ використовуючи MOV, або атаку Фрея-Рюка, що в свою чергу дозволить використати GNFS. На практиці, якщо $p$ - 256 бітне число і $tau = 2$, то розв'язок ECDLP займе приблизно пару годин. Для захисту від цієї атаки, треба переконатися що $p^tau$ достатньо велике для того щоб GNFS в $FF_(p ^ tau)$ був нездійсненний.

Але, якщо параметри кривої підібрано правильно, то найоптимальніший алгоритм вирішення ECDLP має часову складність $O(sqrt(q)) text(", де") q = |E(FF_p)|$.

=== CDH

Нехай $GG - angle.l g angle.r$ - циклічна група порядку $q$, $a, b in ZZ_q$.
Припущення полягає у тому, що якщо зловмисник перехопив $g, g^a, g^b$ він не зможе обчислити $g^(a b)$. Зараз єдиним відомим спрособом роз'язати CDH є розв'язати DLP, але не доведено що DLP і CDH - це рівнозначні проблеми. CDH є сильнішим припущенням ніж DLP. Також, цікавою оболивістю CDH є те, що на відміну від RSA, не існує ефективного способу перевірити по заданому $x$, чи дійсно він є правильною відповіддю на CDH.

=== DDH

Нехай  $GG - angle.l g angle.r$ - циклічна група порядку $q$, $a, b, in ZZ_q$ обраін випадково. Припущеня полягає у тому, що зловмисник не може знаючи $g, q$ відрізнити $(g ^a, g^b, g ^c)$ від $(g^a, g^b, g^(a b))$. Це припущення є сильнішим ніж CDH.

== Twist curves(скручені криві)

Кожна еліптична крива $E slash FF_p$ має пов'язану з нею криву $tilde(E) slash FF_p$, яка називається twist of E(скрученою кривою Е). Нехай $c in FF_p$ не є квадратичним лишком в $FF_p$. Якщо E задається рівнянням $y^2 = x^3 + a x + b$, тоді $tilde(E)$ задається рівнянням $c y^2 = x ^3 + a x + b$.
Нескладно показати, що $|E(FF_p)| + |tilde(E)(FF_p)| = 2p + 2$, з цього, з використанням теореми Гассе, випливає що $|tilde(E)(FF_p)| = p + 1 - t$.

Визначемо, що крива $E slash FF_p$ twist secure(безпечно скручена), якщо ECDLP складно розв'язний як в $E slash FF_p$, так і в $tilde(E) slash FF_p$. 

Розглянемо для чого потрібна twist security. Нехай Боб має секретний ключ $alpha in ZZ_q$, на надіслане $P in E(FF_p)$ Боб відправляє $alpha P$. Для того щоб система була безпечною Боб має перевіряти чи $P in E(FF_p)$, але нехай замість того щоб відсилати $P = (x, y)$, відсилається тільки $x$ координата, тоді також можна як і отримати $y$, так і перевірити чи $in E(FF_p)$. Тоді, перевірка $P in E(FF_p)$ зводиться до перевірки чи є $y^2 = x^3 + a x + b$ квадратичним лишком в $FF_p$, що є відносно дорогою по часу операцією. Нехай, у такому випадку при імплементації крок перевірки був пропущений. Тоді, зловмисник може надіслати Бобу $x_1 = x(tilde(P)) in FF_q, tilde(P) in tilde(E) slash FF_q$. Якщо ECDLP легкорозв'язний в $tilde(E) slash FF_q$, тобто $E slash FF_p$ не twist secure, то відповідь Боба розкриє його секретний ключ. У випадку, якщо $E slash FF_p$ twist secure то Бобу  не загрожує така атака і він може використовувати оптимізацію при якій відправляється тільки $x$ координата і не витрачати час на її перевірку.

== Застосування еліптичних кривих поза межами ECC

Еліптичні криві можна застосувати у криптографії поза межами ECC:

1. Для факторизації, наприклад алгоритм факторизації Ленстра @ECFact. Він має часову складність $O(exp((sqrt(2) + o(1)) sqrt(log p log log p))(log N ^ 2))$ @ECFactComplexity

2. Для тестування на простоту. Існують, наприклад, тести на простоту Atkin–Morain elliptic curve primality test зі складністю $O(log^(6 + epsilon) N)$, для деякого $epsilon > 0$ і Goldwasser–Kilian algorithm зі складністю $O(log^(10 + c_2) N)$, де $c_2$ деяке число більше 0.

Загалом, 20 найбільших чисел простоту яких було доведено, було доведено за допомгою еілптичних кривих @PrimeRank.

== Висновки 

У цьому розліді було розглянуто і дослідження теоретичний фундамент ECC, а саме: розглянуто еліптитчні криві над $RR$, еліптичні криві над полями скінченої характеристики $p$, обчислення над точками еліптичних кривих і їх геометрична інтерпретація для еліптичних кривих над $RR$, обчислення кількості точок еліптичної кривої, досліджено способи обчислення і оптимізації множенння точки еліптичної кривої на ціле число, розглянуто спарювання точок еліптичної кривої, спеціальні випадки еліптичних кривих (Монгомері, Едвардса, Кобліца), досліджено проблему знаходження дискретного логарифму для точок еліптичної кривої і можливі атаки на нього та припущення на яких будується криптографія еліптичних кривих, розглянуто скручування еліптичних кривих і застосування еліптичних кривих поза межами ECC. Як висновок, з цього розділу має бути очевидно, що розробка своєї еліптичної кривої - це складна справа з великою кількістю нюансів, до того ж, неправильно побулована еліптична крива може призвести до того, що криптосистеми з її використанням не будуть безпечними. Тому на практиці використовують набір затверджених, або просто перевірених кривих. Деякі з них будуть розглянуті у наступному.

#pagebreak()

= ЗАСТОСУВАННЯ У КРИПТОГРАФІЇ

== Практична перевага над $ZZ_p ^ *$

== Кодування інформації за допомогою еліптичних кривих

== Приклади еліптичних кривих у сучасній криптографії

=== secp256r1 (P256)
=== secp256k1 (Bitcoin curve)
=== Curve25519
=== bn256

== Імплементація Curve25519

== Протоколи узгодження ключів

=== ECDH

=== X25519

== Протоколи підпису і верифікації

=== ECDSA
=== EdDSA
=== BLS
=== Ed25519

== Порівняння з існуючими імплементаціями

#pagebreak()

#set heading(numbering: none)

= Висновки
#pagebreak()

= Перелік джерел посилання
#bibliography(title: none, "sources.yml")